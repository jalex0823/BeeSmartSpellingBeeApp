{% extends "base.html" %}

{% block title %}BeeSmart Speed Round - Race Against Time!{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/BeeSmart.css') }}">
<style>
    body {
        background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 50%, #90CAF9 100%);
        overflow-x: hidden;
    }

    /* Voice Visualizer wrapper */
    .voice-visualizer { margin-bottom: 1.5rem; }

    .voice-visualizer::before { display: none; }

    /* New dotted ribbon card skin */
        .voice-card.speaking-mode {
                background: #FFB300; /* solid amber */
                border-radius: 28px;
                padding: 24px 16px 32px;
                border: none; /* remove border */
                box-shadow: 0 24px 40px rgba(255,140,0,0.28);
                max-width: 520px;
                margin: 0 auto 24px auto;
                color: #fff;
                text-align: center;
                font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", "Roboto", sans-serif;
                overflow: hidden; /* keep dots within card corners */
        }
    .voice-header {
        font-size: 1.25rem;
        font-weight: 600;
        color: #fff8e1;
        text-shadow: 0 0 6px rgba(255,255,255,0.8), 0 0 12px rgba(255,214,64,0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        letter-spacing: 0.02em;
        margin-bottom: 20px;
    }
    .voice-bee { margin-right: 8px; display:inline-block; filter: drop-shadow(0 0 4px #fff) drop-shadow(0 0 8px #ffd54f); }
    .dotwave-wrapper { display:flex; justify-content:center; align-items:center; padding: 8px 16px; }
    .dotwave-wrapper canvas { width: 100%; height: 180px; filter: drop-shadow(0 0 4px rgba(255,255,255,0.4)) drop-shadow(0 0 12px rgba(255,200,0,0.4)); }

    .speed-quiz-container {
        max-width: 550px;
        margin: 0 auto;
        padding: 1.5rem 1rem 2rem;
        text-align: center;
    }

    /* Header with stats */
    .speed-header {
        background: linear-gradient(135deg, #FFFFFF 0%, #FFF9E6 100%);
        border-radius: 24px;
        padding: 1.5rem;
        margin-bottom: 1.5rem;
        box-shadow: 0 12px 30px rgba(255, 140, 0, 0.25);
        border: 3px solid #FFD700;
        position: relative;
        overflow: hidden;
    }

    .speed-header::before {
        content: '‚ö°';
        position: absolute;
        top: -10px;
        right: -10px;
        font-size: 100px;
        opacity: 0.08;
        transform: rotate(-15deg);
    }

    .speed-title {
        font-size: 1.8rem;
        font-weight: 800;
        color: #1976D2;
        margin-bottom: 1rem;
        text-shadow: 2px 2px 4px rgba(25, 118, 210, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }

    /* Stats Grid */
    .stats-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 0.75rem;
        margin-top: 1rem;
    }

    .stat-box {
        background: linear-gradient(135deg, #E3F2FD 0%, #BBDEFB 100%);
        border: 2px solid #42A5F5;
        border-radius: 16px;
        padding: 0.75rem 0.5rem;
        transition: all 0.3s ease;
    }

    .stat-box.highlight {
        background: linear-gradient(135deg, #42A5F5 0%, #2196F3 100%);
        transform: scale(1.1);
        box-shadow: 0 8px 20px rgba(33, 150, 243, 0.5);
    }

    .stat-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #0D47A1;
        margin-bottom: 0.25rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .stat-value {
        font-size: 1.5rem;
        font-weight: 800;
        color: #1976D2;
    }

    .stat-box.highlight .stat-label,
    .stat-box.highlight .stat-value {
        color: #FFFFFF;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
    }

    /* Circular Timer */
    .timer-container {
        position: relative;
        width: 180px;
        height: 180px;
        margin: 1.5rem auto;
    }

    .timer-svg {
        transform: rotate(-90deg);
        filter: drop-shadow(0 8px 20px rgba(25, 118, 210, 0.4));
    }

    .timer-circle-bg {
        fill: none;
        stroke: #BBDEFB;
        stroke-width: 12;
    }

    .timer-circle {
        fill: none;
        stroke: url(#timerGradient);
        stroke-width: 12;
        stroke-linecap: round;
        transition: stroke-dashoffset 0.1s linear;
    }

    .timer-circle.warning {
        stroke: url(#warningGradient);
        animation: pulse 0.5s ease-in-out infinite;
    }

    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .timer-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 3rem;
        font-weight: 800;
        color: #1976D2;
        text-shadow: 2px 2px 4px rgba(25, 118, 210, 0.2);
        line-height: 1;
    }

    .timer-text.warning {
        color: #FF4444;
        animation: shake 0.5s ease-in-out infinite;
    }

    @keyframes shake {
        0%, 100% { transform: translate(-50%, -50%) rotate(0deg); }
        25% { transform: translate(-50%, -50%) rotate(-3deg); }
        75% { transform: translate(-50%, -50%) rotate(3deg); }
    }

    .timer-label {
        position: absolute;
        bottom: 25px;
        left: 50%;
        transform: translateX(-50%);
        font-size: 0.9rem;
        font-weight: 600;
        color: #8B6914;
        text-transform: uppercase;
        letter-spacing: 1px;
    }

    /* Quiz Content */
    .quiz-card {
        background: #FFFFFF;
        border-radius: 24px;
        padding: 2rem 1.5rem;
        box-shadow: 0 15px 40px rgba(255, 140, 0, 0.3);
        border: 3px solid #FFD700;
        margin-bottom: 1.5rem;
    }

    .word-prompt {
        font-size: 1.3rem;
        font-weight: 700;
        color: #5d4100;
        margin-bottom: 1rem;
        line-height: 1.6;
        min-height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Input Section */
    .input-section {
        margin-top: 1.5rem;
    }

    .spell-input {
        width: 100%;
        padding: 1rem 1.5rem;
        font-size: 1.5rem;
        font-weight: 700;
        text-align: center;
        border: 3px solid #42A5F5;
        border-radius: 16px;
        background: #E3F2FD;
        color: #1976D2;
        transition: all 0.2s;
        margin-bottom: 1rem;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    .spell-input:focus {
        outline: none;
        border-color: #1976D2;
        box-shadow: 0 0 0 4px rgba(25, 118, 210, 0.2);
        background: #FFFFFF;
    }

    /* Action Buttons */
    .action-buttons {
        display: flex;
        gap: 0.75rem;
        justify-content: center;
        flex-wrap: wrap;
    }

    .btn-speed {
        padding: 0.9rem 1.8rem;
        font-size: 1.1rem;
        font-weight: 800;
        border: none;
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
        display: flex;
        align-items: center;
        gap: 0.5rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .btn-submit {
        background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
        color: white;
        border: 3px solid #2e7d32;
        flex: 1;
        min-width: 180px;
    }

    .btn-submit:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(76, 175, 80, 0.4);
    }

    .btn-pronounce {
        background: linear-gradient(135deg, #FFA500 0%, #FF8C00 100%);
        color: white;
        border: 3px solid #FF6B00;
    }

    .btn-pronounce:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(255, 165, 0, 0.4);
    }

    .btn-hint {
        background: linear-gradient(135deg, #4aa3ff 0%, #1e88e5 100%);
        color: white;
        border: 3px solid #1565c0;
    }

    .btn-hint:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(30, 136, 229, 0.4);
    }

    .btn-skip {
        background: linear-gradient(135deg, #9E9E9E 0%, #757575 100%);
        color: white;
        border: 3px solid #616161;
    }

    .btn-skip:hover {
        transform: translateY(-3px);
        box-shadow: 0 10px 25px rgba(158, 158, 158, 0.4);
    }

    /* Feedback Messages */
    .feedback-message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: rgba(255, 255, 255, 0.98);
        padding: 2rem 3rem;
        border-radius: 24px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        z-index: 10000;
        text-align: center;
        border: 4px solid;
        animation: feedbackPop 0.5s ease forwards;
    }

    .feedback-message.correct {
        border-color: #4CAF50;
    }

    .feedback-message.incorrect {
        border-color: #FF4444;
    }

    .feedback-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        animation: bounce 0.6s ease;
    }

    .feedback-text {
        font-size: 1.5rem;
        font-weight: 800;
        margin-bottom: 0.5rem;
    }

    .feedback-subtext {
        font-size: 1rem;
        font-weight: 600;
        opacity: 0.8;
    }

    @keyframes feedbackPop {
        0% { transform: translate(-50%, -50%) scale(0); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); }
    }

    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-20px); }
    }

    /* Loading State */
    .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(255, 249, 230, 0.95);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        flex-direction: column;
        gap: 1.5rem;
    }

    .loading-bee {
        font-size: 5rem;
        animation: fly 2s ease-in-out infinite;
    }

    @keyframes fly {
        0%, 100% { transform: translateY(0) rotate(0deg); }
        25% { transform: translateY(-30px) rotate(-10deg); }
        75% { transform: translateY(-30px) rotate(10deg); }
    }

    .loading-text {
        font-size: 1.5rem;
        font-weight: 800;
        color: #FF6B00;
        text-shadow: 2px 2px 4px rgba(255, 107, 0, 0.2);
    }

    /* Responsive Design */
    @media (max-width: 480px) {
        .speed-quiz-container {
            padding: 1rem 0.75rem;
        }

        .speed-title {
            font-size: 1.4rem;
        }

        .stats-grid {
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
        }

        .stat-value {
            font-size: 1.2rem;
        }

        .timer-container {
            width: 140px;
            height: 140px;
        }

        .timer-text {
            font-size: 2.5rem;
        }

        .spell-input {
            font-size: 1.2rem;
            padding: 0.8rem 1rem;
        }

        .btn-speed {
            padding: 0.8rem 1.5rem;
            font-size: 1rem;
        }

        .action-buttons {
            flex-direction: column;
        }

        .btn-submit {
            min-width: 100%;
        }
    }
</style>
{% endblock %}

{% block content %}
<!-- ‚ö†Ô∏è ERROR BOUNDARY ‚ö†Ô∏è -->
<div id="errorBoundary" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 10000; align-items: center; justify-content: center;">
    <div style="background: linear-gradient(135deg, #FF6B6B 0%, #FF4444 100%); border-radius: 30px; padding: 3rem; max-width: 600px; width: 90%; text-align: center; box-shadow: 0 20px 60px rgba(0,0,0,0.5); border: 5px solid #FF0000;">
        <div style="font-size: 5rem; margin-bottom: 1rem;">‚ö†Ô∏è</div>
        <h2 id="errorTitle" style="color: white; font-size: 2rem; margin-bottom: 1rem;">Error</h2>
        <p id="errorMessage" style="color: rgba(255,255,255,0.9); font-size: 1.2rem; margin-bottom: 2rem; line-height: 1.6;"></p>
        <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
            <button id="errorRetryBtn" onclick="retrySpeedRound()" style="display: none; padding: 1rem 2rem; font-size: 1.2rem; background: linear-gradient(135deg, #4CAF50, #45A049); color: white; border: none; border-radius: 15px; cursor: pointer; font-weight: 700; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
                üîÑ Try Again
            </button>
            <button onclick="window.location.href='/speed-round/setup'" style="padding: 1rem 2rem; font-size: 1.2rem; background: linear-gradient(135deg, #FFB300, #FFA500); color: #2B1B00; border: none; border-radius: 15px; cursor: pointer; font-weight: 700; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
                ‚Üê Back to Setup
            </button>
            <button onclick="window.location.href='/'" style="padding: 1rem 2rem; font-size: 1.2rem; background: linear-gradient(135deg, #9E9E9E, #757575); color: white; border: none; border-radius: 15px; cursor: pointer; font-weight: 700; box-shadow: 0 5px 15px rgba(0,0,0,0.3);">
                üè† Main Menu
            </button>
        </div>
    </div>
</div>

<div class="speed-quiz-container">
    <!-- Header with Stats -->
    <div class="speed-header">
        <div class="speed-title">
            <span>‚ö°</span>
            <span>Speed Round</span>
            <span>‚ö°</span>
        </div>
        
        <div class="stats-grid">
            <div class="stat-box" id="progressBox">
                <div class="stat-label">Progress</div>
                <div class="stat-value" id="progressStat">0/0</div>
            </div>
            <div class="stat-box" id="streakBox">
                <div class="stat-label">üî• Streak</div>
                <div class="stat-value" id="streakStat">0</div>
            </div>
            <div class="stat-box" id="pointsBox">
                <div class="stat-label">üí∞ Points</div>
                <div class="stat-value" id="pointsStat">0</div>
            </div>
        </div>
    </div>

    <!-- Circular Timer -->
    <div class="timer-container">
        <svg class="timer-svg" width="180" height="180" viewBox="0 0 180 180">
            <defs>
                <linearGradient id="timerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#42A5F5;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#1976D2;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="warningGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#1976D2;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#FF4444;stop-opacity:1" />
                </linearGradient>
            </defs>
            <circle class="timer-circle-bg" cx="90" cy="90" r="80"></circle>
            <circle id="timerCircle" class="timer-circle" cx="90" cy="90" r="80"></circle>
        </svg>
        <div id="timerText" class="timer-text">0</div>
        <div class="timer-label">SECONDS</div>
    </div>

    <!-- Quiz Card -->
    <div class="quiz-card">
                <!-- Voice Visualizer (Upgraded dotted rainbow ribbon) -->
                <div class="voice-visualizer" id="voiceVisualizer">
                        <div class="voice-card speaking-mode">
                            <div class="voice-header">
                                <span class="voice-bee">üêù</span>
                                <span class="voice-text" id="voiceStatus">Ready</span>
                            </div>
                            <div class="dotwave-wrapper">
                                <canvas id="dotWaveCanvas" width="500" height="160"></canvas>
                            </div>
                        </div>
                </div>

        <div class="word-prompt" id="wordPrompt">
            üêù Listen carefully and spell the word! üêù
        </div>

        <div class="input-section">
            <input 
                type="text" 
                id="spellInput" 
                class="spell-input" 
                placeholder="Type your answer..." 
                autocomplete="off"
                autocorrect="off"
                autocapitalize="off"
                spellcheck="false"
            />

            <div class="action-buttons">
                <button class="btn-speed btn-submit" id="submitBtn">
                    <span>‚úì</span>
                    <span>Submit Answer</span>
                </button>
            </div>

            <div class="action-buttons" style="margin-top: 0.75rem;">
                <button class="btn-speed btn-pronounce" id="pronounceBtn">
                    <span>üîä</span>
                    <span>Pronounce</span>
                </button>
                <button class="btn-speed btn-hint" id="hintBtn">
                    <span>üí°</span>
                    <span>Hint</span>
                </button>
                <button class="btn-speed btn-skip" id="skipBtn">
                    <span>‚è≠</span>
                    <span>Skip</span>
                </button>
                <button class="btn-speed" onclick="window.location.href='/'" style="background: linear-gradient(135deg, #9E9E9E, #757575);">
                    <span>üè†</span>
                    <span>Menu</span>
                </button>
            </div>

            <div id="hintArea" style="display:none; margin-top:0.75rem; font-weight:700; color:#1e3a8a;">
                
            </div>
        </div>
    </div>
</div>

<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay" style="display: none;">
    <div class="loading-bee">üêù</div>
    <div class="loading-text">Loading Speed Round...</div>
</div>

<script src="/static/js/voice-visualizer-config.js"></script>
<script>
// Speed Round Quiz State
let currentWord = null;
let timeRemaining = 0;
let maxTime = 0;
let timerInterval = null;
let wordStartTime = null;
let totalWords = 0;
let currentIndex = 0;
let currentStreak = 0;
let totalPoints = 0;
let currentHint = '';
let currentSentence = '';
// Enhanced voice selection algorithm for natural-sounding female voices
function isIOS() {
    const ua = navigator.userAgent || navigator.vendor || window.opera;
    const isAppleMobile = /iPad|iPhone|iPod/.test(ua);
    // iPadOS 13+ reports as Mac; detect touch-capable Mac
    const isIPadOS = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    return isAppleMobile || isIPadOS;
}
function selectBestFemaleVoice() {
    const voices = speechSynthesis.getVoices();
    console.log('üé§ Speed Round: Analyzing', voices.length, 'available voices for best female selection');
    
    // iOS-specific override: lock to stable, female Apple voices when available
    if (isIOS() && voices.length) {
        const iosPreferred = [
            // US first
            'samantha', 'siri', 'ava', 'olivia',
            // Other English regions as fallbacks
            'victoria', 'karen', 'moira', 'tessa'
        ];
        const lower = name => (name || '').toLowerCase();
        // Prefer en-US first
        for (const name of iosPreferred) {
            const v = voices.find(v => v.lang.startsWith('en-US') && lower(v.name).includes(name));
            if (v) { console.log('üì± iOS preferred voice selected:', v.name, v.lang); return v; }
        }
        // Then any English
        for (const name of iosPreferred) {
            const v = voices.find(v => v.lang.startsWith('en') && lower(v.name).includes(name));
            if (v) { console.log('üì± iOS fallback preferred voice selected:', v.name, v.lang); return v; }
        }
        // If none matched, continue to generic scoring below
    }
    
    // Score voices based on multiple criteria
    const scoredVoices = voices
        .filter(voice => voice.lang.startsWith('en')) // English only
        .map(voice => {
            let score = 0;
            const name = voice.name.toLowerCase();
            
            // Language preference (US English gets highest priority)
            if (voice.lang === 'en-US') score += 100;
            else if (voice.lang.startsWith('en-')) score += 50;
            
            // Quality indicators (higher quality = more natural)
            if (voice.quality === 'high') score += 50;
            else if (voice.quality === 'enhanced') score += 40;
            else if (voice.quality === 'normal') score += 20;
            
            // Local voices often sound more natural than cloud-based
            if (voice.localService) score += 30;
            
            // Explicit female voice indicators
            if (name.includes('female')) score += 80;
            if (name.includes('woman')) score += 80;
            
            // Premium/Natural voice names (typically higher quality)
            if (name.includes('natural')) score += 60;
            if (name.includes('premium')) score += 60;
            if (name.includes('neural')) score += 60;
            
            // Known high-quality female voices (ordered by naturalness)
            const premiumVoices = {
                'samantha': 90,     // macOS - very natural
                'alex': 85,         // macOS - excellent quality
                'victoria': 80,     // Windows - natural sounding
                'zira': 75,         // Windows - clear and natural
                'aria': 85,         // Modern Windows neural
                'jenny': 85,        // Modern neural voice
                'nova': 80,         // Modern neural voice
                'allison': 70,      // Traditional but good
                'ava': 70,          // Traditional but good
                'joanna': 65,       // Amazon Polly style
                'susan': 60,        // Traditional
                'karen': 55,        // Traditional
                'moira': 50         // Traditional Irish
            };
            
            // Check for premium voice names
            for (const [voiceName, points] of Object.entries(premiumVoices)) {
                if (name.includes(voiceName)) {
                    score += points;
                    break;
                }
            }
            
            // Avoid robotic or synthetic-sounding voices
            if (name.includes('robot')) score -= 50;
            if (name.includes('synthetic')) score -= 30;
            if (name.includes('microsoft') && !name.includes('aria')) score -= 10;
            
            return { voice, score };
        })
        .sort((a, b) => b.score - a.score);
    
    if (scoredVoices.length > 0) {
        const bestVoice = scoredVoices[0].voice;
        console.log(`üèÜ Speed Round: Selected best voice: ${bestVoice.name} (${bestVoice.lang}) with score ${scoredVoices[0].score}`);
        return bestVoice;
    }
    
    console.warn('‚ö†Ô∏è Speed Round: No suitable female voice found');
    return null;
}

let cachedVoice = null; // cache selected voice for consistency
let speechSynthesisInitialized = false; // iOS speech initialization flag
let wordsUntilNameAnnouncement = 0; // Track sporadic name announcements (0 = announce now)
// Try to personalize announcements with locally stored student name (set on quiz page)
let studentName = '';
// Prefer server-provided name when available; fall back to localStorage for continuity
{% if user_name %}
studentName = {{ user_name|tojson }};
try { localStorage.setItem('studentName', studentName); } catch (e) {}
{% else %}
try {
    studentName = localStorage.getItem('studentName') || '';
} catch (e) {
    studentName = '';
}
{% endif %}

// Mask target word in text to prevent cheating
function maskTargetWord(text, targetWord) {
    if (!text || !targetWord) return text;
    
    // Create regex that matches the word with word boundaries (case-insensitive)
    // Escape special regex characters in the target word
    const escapedWord = targetWord.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`\\b${escapedWord}\\b`, 'gi');
    
    // Replace with underscores (5 underscores as placeholder)
    return text.replace(regex, '_____');
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    // iOS Critical Fix: Set up event listeners IMMEDIATELY on page load
    // Don't wait for speech synthesis to complete
    setupEventListeners();
    
    // iOS Speech Synthesis Fix: Force initialization with user interaction
    initializeSpeechSynthesisForIOS();
    
    // Announce Speed Round intro first, then load first word
    announceSpeedRoundIntro();
});

// iOS requires speechSynthesis to be triggered by user interaction
function initializeSpeechSynthesisForIOS() {
    if (!('speechSynthesis' in window)) return;
    
    // Pre-load voices for iOS
    if (speechSynthesis.getVoices().length === 0) {
        speechSynthesis.addEventListener('voiceschanged', () => {
            speechSynthesisInitialized = true;
            console.log('üéôÔ∏è iOS voices loaded:', speechSynthesis.getVoices().length);
        }, { once: true });
    } else {
        speechSynthesisInitialized = true;
    }
    
    // Force iOS to initialize by creating and immediately canceling an utterance
    const testUtterance = new SpeechSynthesisUtterance('');
    testUtterance.volume = 0;
    speechSynthesis.speak(testUtterance);
    speechSynthesis.cancel();
    
    console.log('üçé iOS Speech Synthesis initialized');
}

function announceSpeedRoundIntro() {
    const visualizer = document.getElementById('voiceVisualizer');
    const status = document.getElementById('voiceStatus');
    
    if (!('speechSynthesis' in window)) {
        // If no speech support, just start the round
        // Note: Event listeners already set up on DOMContentLoaded
        setTimeout(() => {
            loadNextWord();
        }, 1000);
        return;
    }

    const intro = `${studentName ? studentName + ', ' : ''}Welcome to the Speed Round! Get ready for an exciting challenge. ` +
                  "You'll have limited time to spell each word correctly. " +
                  "Listen carefully, type fast, and earn bonus points for quick answers! " +
                  "Your Speed Round begins... now!";
    
    // iOS Fix: Cancel any existing speech with delay
    speechSynthesis.cancel();
    
    // iOS Fix: Add 100ms delay after cancel
    setTimeout(() => {
        const utterance = new SpeechSynthesisUtterance(intro);
        utterance.pitch = 1.35;
        utterance.rate = 0.95;
        utterance.volume = 0.9;

        // Use the same best-female voice selector as regular quiz
        // This avoids defaulting to a male voice on some systems
        const bestVoice = selectBestFemaleVoice();
        if (bestVoice) {
            utterance.voice = bestVoice;
            cachedVoice = bestVoice; // Cache for subsequent calls
        }
        
        status.textContent = 'üéôÔ∏è Welcome to Speed Round!';
        
        utterance.onstart = () => {
            visualizer.classList.add('speaking');
        };

        // Boundary-driven pauses during announcement
        utterance.onboundary = (event) => {
            if (!visualizer) return;
            if (event.name === 'word' || event.charLength > 0) {
                visualizer.classList.add('word-pulse');
                setTimeout(() => visualizer.classList.remove('word-pulse'), 150);
                visualizer.classList.add('pausing');
                setTimeout(() => visualizer.classList.remove('pausing'), 100);
            }
            const ch = (utterance.text || '').charAt(event.charIndex);
            if (ch === '.' || ch === '!' || ch === '?' || ch === ';' || ch === ',') {
                visualizer.classList.remove('speaking');
                visualizer.classList.add('pausing');
                setTimeout(() => {
                    visualizer.classList.remove('pausing');
                    visualizer.classList.add('speaking');
                }, 400);
            }
        };

        // Sync visualizer with intro speech using natural pauses
        utterance.onboundary = (event) => {
            if (!visualizer) return;
            if (event.name === 'word' || event.charLength > 0) {
                visualizer.classList.add('word-pulse');
                setTimeout(() => visualizer.classList.remove('word-pulse'), 150);
                visualizer.classList.add('pausing');
                setTimeout(() => visualizer.classList.remove('pausing'), 100);
            }
            const ch = (utterance.text || '').charAt(event.charIndex);
            if (ch === '.' || ch === '!' || ch === '?' || ch === ';' || ch === ',') {
                visualizer.classList.remove('speaking');
                visualizer.classList.add('pausing');
                setTimeout(() => {
                    visualizer.classList.remove('pausing');
                    visualizer.classList.add('speaking');
                }, 400);
            }
        };
        
        utterance.onend = () => {
            visualizer.classList.remove('speaking');
            status.textContent = 'üêù Ready';
            // Start the actual quiz after intro
            setTimeout(() => {
                loadNextWord();
                // Note: setupEventListeners() already called on DOMContentLoaded for iOS compatibility
            }, 500);
        };
        
        utterance.onerror = () => {
            visualizer.classList.remove('speaking');
            // Start anyway if there's an error
            loadNextWord();
            // Note: setupEventListeners() already called on DOMContentLoaded for iOS compatibility
        };
        
        try {
            speechSynthesis.speak(utterance);
        } catch (err) {
            console.error('speechSynthesis.speak failed:', err);
            // Trigger onend behavior manually
            if (typeof utterance.onend === 'function') utterance.onend();
        }
        
        // iOS fallback - reload voices if empty
        if (speechSynthesis.getVoices().length === 0) {
            speechSynthesis.addEventListener('voiceschanged', () => {
                const fallback = selectBestFemaleVoice() || speechSynthesis.getVoices().find(v => v.lang.startsWith('en'));
                if (fallback) utterance.voice = fallback;
            }, { once: true });
        }
    }, 100); // iOS Fix: 100ms delay
}

function setupEventListeners() {
    // iOS Fix: Add both click and touchend events for better mobile support
    const addButtonHandler = (id, handler, reactType) => {
        const btn = document.getElementById(id);
        if (!btn) return;
        
        const wrappedHandler = (e) => {
            e.preventDefault(); // Prevent double-firing on iOS
            try { window.BeeVoiceViz?.react(reactType); } catch (err) {}
            handler();
        };
        
        // Remove any existing listeners first
        btn.replaceWith(btn.cloneNode(true));
        const freshBtn = document.getElementById(id);
        
        freshBtn.addEventListener('click', wrappedHandler);
        freshBtn.addEventListener('touchend', wrappedHandler);
    };
    
    // Submit button
    addButtonHandler('submitBtn', () => submitAnswer(), 'submit');
    
    // Pronounce button
    addButtonHandler('pronounceBtn', () => pronounceWord(), 'button');
    
    // Hint button
    addButtonHandler('hintBtn', () => showHint(), 'hint');
    
    // Skip button
    addButtonHandler('skipBtn', () => submitAnswer(true), 'skip');
    
    // Enter key to submit
    const spellInput = document.getElementById('spellInput');
    if (spellInput) {
        spellInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                try { window.BeeVoiceViz?.react('submit'); } catch (e2) {}
                submitAnswer();
            }
        });
    }
}

async function loadNextWord() {
    try {
        // Stop any existing timer
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }

        // iOS Fix: Add timeout to prevent hanging fetch requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
        
        const response = await fetch('/api/speed-round/next', {
            signal: controller.signal
        });
        clearTimeout(timeoutId);
        
        // Guard: Check response is valid
        if (!response || !response.ok) {
            throw new Error('Failed to fetch next word from server');
        }
        
        const data = await response.json();
        
        // Guard: Validate data structure
        if (!data || typeof data !== 'object') {
            throw new Error('Invalid data received from server');
        }

        if (data.complete) {
            // Round is complete
            completeRound();
            return;
        }

        if (data.error) {
            showErrorBoundary('Speed Round Error', data.error || 'Unknown error occurred');
            return;
        }

        // Guard: Validate word data exists
        if (!data.word || typeof data.word !== 'string' || data.word.trim().length === 0) {
            throw new Error('Invalid word data received');
        }
        
        // Guard: Validate required fields
        if (typeof data.time_per_word !== 'number' || data.time_per_word <= 0) {
            throw new Error('Invalid timer configuration');
        }

        // Update current word state
        currentWord = data.word;
        timeRemaining = data.time_per_word;
        maxTime = data.time_per_word;
        currentIndex = data.current_index || 0;
        totalWords = data.total_words || 1;
        currentStreak = data.current_streak || 0;
        totalPoints = data.total_points || 0;

        console.log('üìù Word loaded:', currentWord, '| Time:', timeRemaining, 'seconds | Progress:', currentIndex, '/', totalWords);

        // Update UI
        updateStats();
        clearInput();
        
        // Lock input until countdown finishes
        const spellInput = document.getElementById('spellInput');
        const submitBtn = document.getElementById('submitBtn');
        if (spellInput) {
            spellInput.disabled = true;
            spellInput.placeholder = "Wait for countdown...";
        }
        if (submitBtn) {
            submitBtn.disabled = true;
        }
        
        const wordPrompt = document.getElementById('wordPrompt');
        if (wordPrompt) {
            // Mask the target word in the definition to prevent cheating
            const maskedDefinition = maskTargetWord(data.definition || 'üêù Listen carefully and spell the word! üêù', data.word);
            wordPrompt.textContent = maskedDefinition;
        }
        
        // Mask target word in hint and sentence to prevent cheating
        currentHint = maskTargetWord(data.hint || '', data.word);
        currentSentence = maskTargetWord(data.sentence || '', data.word);
        
        // Hide any previous hint
        const hintArea = document.getElementById('hintArea');
        if (hintArea) {
            hintArea.style.display = 'none';
            hintArea.textContent = '';
        }
        
        // Announce word context, then auto-pronounce
        announceWord(currentIndex, totalWords);

        // Start timer
        wordStartTime = Date.now();
        startTimer();

    } catch (error) {
        console.error('‚ùå Error loading next word:', error);
        
        // iOS-specific error handling for aborted requests
        if (error.name === 'AbortError') {
            showErrorBoundary(
                'Connection Timeout',
                'The request took too long. Please check your internet connection and try again.',
                true
            );
        } else {
            showErrorBoundary(
                'Speed Round content failed to load',
                'We couldn\'t load the next word. This might be a temporary issue.',
                true // Show retry button
            );
        }
    }
}
        
        // Hide any previous hint
        const hintArea = document.getElementById('hintArea');
        if (hintArea) {
            hintArea.style.display = 'none';
            hintArea.textContent = '';
        }
        
        // Announce word context, then auto-pronounce
        announceWord(currentIndex, totalWords);

        // Start timer
        wordStartTime = Date.now();
        startTimer();

    } catch (error) {
        console.error('‚ùå Error loading next word:', error);
        showErrorBoundary(
            'Speed Round content failed to load',
            'We couldn\'t load the next word. This might be a temporary issue.',
            true // Show retry button
        );
    }
}

function showHint() {
    const hintArea = document.getElementById('hintArea');
    let text = '';
    if (currentHint && currentHint.trim().length > 0) {
        text = `Hint: ${currentHint}`;
    } else if (currentSentence && currentSentence.trim().length > 0) {
        text = currentSentence;
    } else {
        text = 'No hint available for this word yet. Try listening again.';
    }
    hintArea.textContent = text;
    hintArea.style.display = 'block';
}

function startTimer() {
    try {
        // Guard: Validate timer elements exist
        const circle = document.getElementById('timerCircle');
        const timerText = document.getElementById('timerText');
        
        if (!circle || !timerText) {
            console.error('‚ùå Timer elements not found in DOM');
            return;
        }
        
        // Guard: Validate timer values BEFORE starting
        if (typeof timeRemaining !== 'number' || timeRemaining <= 0) {
            console.error('‚ùå Invalid timeRemaining value:', timeRemaining);
            timeRemaining = 15; // Fallback to 15 seconds
        }
        
        if (typeof maxTime !== 'number' || maxTime <= 0) {
            console.error('‚ùå Invalid maxTime value:', maxTime);
            maxTime = timeRemaining;
        }
        
        // Log timer start for debugging
        console.log('‚è±Ô∏è Starting timer - timeRemaining:', timeRemaining, 'maxTime:', maxTime);
        
        const circumference = 2 * Math.PI * 80;
        
        circle.style.strokeDasharray = circumference;
        circle.style.strokeDashoffset = 0;

        // Clear any existing timer interval
        if (timerInterval) {
            clearInterval(timerInterval);
        }

        timerInterval = setInterval(() => {
            timeRemaining -= 0.1;

            if (timeRemaining <= 0) {
                console.log('‚è±Ô∏è Timer expired - auto-submitting');
                clearInterval(timerInterval);
                timerInterval = null;
                timeRemaining = 0;
                // Auto-submit as incorrect when time runs out
                submitAnswer(true);
                return;
            }

            // Update timer display
            const seconds = Math.ceil(timeRemaining);
            if (timerText) {
                timerText.textContent = seconds;
            }

            // Update circle progress
            const progress = timeRemaining / maxTime;
            const offset = circumference * (1 - progress);
            if (circle) {
                circle.style.strokeDashoffset = offset;
            }

            // Warning state at 30% time remaining
            if (progress <= 0.3) {
                if (circle) circle.classList.add('warning');
                if (timerText) timerText.classList.add('warning');
            } else {
                if (circle) circle.classList.remove('warning');
                if (timerText) timerText.classList.remove('warning');
            }

        }, 100);
    } catch (error) {
        console.error('‚ùå Error starting timer:', error);
        showErrorBoundary('Timer Error', 'Failed to start countdown timer. Please try again.');
    }
}

function updateStats() {
    document.getElementById('progressStat').textContent = `${currentIndex}/${totalWords}`;
    document.getElementById('streakStat').textContent = currentStreak;
    document.getElementById('pointsStat').textContent = totalPoints;
}

function clearInput() {
    document.getElementById('spellInput').value = '';
    document.getElementById('spellInput').focus();
}

function announceWord(wordIndex, totalWords) {
    const visualizer = document.getElementById('voiceVisualizer');
    const status = document.getElementById('voiceStatus');
    
    if (!('speechSynthesis' in window)) {
        // If no speech support, just pronounce the word
        setTimeout(pronounceWord, 100);
        return;
    }

    // Decide whether to add student name sporadically
    const shouldAnnounceName = wordsUntilNameAnnouncement <= 0 && !!studentName;

    // Build a friendly announcement phrase
    const basePhrase = (wordIndex === 1)
        ? 'Your first word is'
        : (wordIndex === totalWords ? 'This is your last word' : 'Your next word is');

    let announcement = basePhrase + '...';

    if (shouldAnnounceName) {
        const options = [
            `${studentName}, ${basePhrase.toLowerCase()}...`,
            `Alright ${studentName}, ${basePhrase.toLowerCase()}...`,
            `${basePhrase}... ${studentName}!`
        ];
        announcement = options[Math.floor(Math.random() * options.length)];
        // Reset counter to announce name again after a few words (3‚Äì5)
        wordsUntilNameAnnouncement = Math.floor(Math.random() * 3) + 3;
    } else {
        // If not including name, occasionally use a shorter transition
        if (Math.random() < 0.25) announcement = 'Next...';
        wordsUntilNameAnnouncement = Math.max(0, wordsUntilNameAnnouncement - 1);
    }
    
    // iOS Fix: Cancel with delay
    speechSynthesis.cancel();
    
    setTimeout(() => {
        const utterance = new SpeechSynthesisUtterance(announcement);
        utterance.pitch = 1.35;
        utterance.rate = 0.92;
        utterance.volume = 0.9;
        
        // Use cached voice or select enhanced one (US English)
        if (cachedVoice) {
            utterance.voice = cachedVoice;
        } else {
            // Select and cache the best female voice (same logic as quiz)
            cachedVoice = selectBestFemaleVoice();
            if (cachedVoice) {
                utterance.voice = cachedVoice;
            }
        }
        
        status.textContent = 'üéôÔ∏è Announcing...';
        
        utterance.onstart = () => {
            visualizer.classList.add('speaking');
        };
        
        utterance.onend = () => {
            visualizer.classList.remove('speaking');
            status.textContent = 'üêù Ready';
            // Add 500ms pause between announcement and word pronunciation
            visualizer.classList.add('pausing');
            setTimeout(() => {
                visualizer.classList.remove('pausing');
                pronounceWord();
            }, 500);
        };
        
        utterance.onerror = () => {
            visualizer.classList.remove('speaking');
            // Pronounce anyway if there's an error (with same pause)
            visualizer.classList.add('pausing');
            setTimeout(() => {
                visualizer.classList.remove('pausing');
                pronounceWord();
            }, 500);
        };
        
        speechSynthesis.speak(utterance);
        
        // iOS fallback - reload voices if empty
        if (speechSynthesis.getVoices().length === 0) {
            speechSynthesis.addEventListener('voiceschanged', () => {
                const voices = speechSynthesis.getVoices();
                const voice = voices.find(v => v.lang.startsWith('en'));
                if (voice) utterance.voice = voice;
            }, { once: true });
        }
    }, 100); // iOS Fix: 100ms delay
}

function pronounceWord() {
    if (!currentWord) return;

    const visualizer = document.getElementById('voiceVisualizer');
    const status = document.getElementById('voiceStatus');
    const word = typeof currentWord === 'string' ? currentWord : (currentWord.word || '');

    if (!('speechSynthesis' in window)) {
        status.textContent = 'üîá Speech not supported';
        return;
    }

    // iOS Fix: Cancel with delay
    speechSynthesis.cancel();

    setTimeout(() => {
    // Speak a friendly prompt and the word twice
    const phrase = `Spell the word ${word}. ${word}.`;
    const utterance = new SpeechSynthesisUtterance(phrase);
        utterance.pitch = 1.35;
        utterance.rate = 0.92;
        utterance.volume = 0.9;
    utterance.text = phrase;

        // Select enhanced US English female voice for American pronunciation
        if (!cachedVoice) {
            cachedVoice = selectBestFemaleVoice();
        }

        if (cachedVoice) {
            utterance.voice = cachedVoice;
            status.textContent = `üéôÔ∏è Speaking (${cachedVoice.lang} ‚Ä¢ ${cachedVoice.name})`;
        } else {
            status.textContent = 'üéôÔ∏è Speaking';
        }

        // Visualizer state
        utterance.onstart = () => {
            visualizer.classList.add('speaking');
            status.textContent = status.textContent || 'üéôÔ∏è Speaking';
        };
        utterance.onend = () => {
            visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
            status.textContent = 'üêù Ready';
            
            // Unlock input after word is pronounced
            const spellInput = document.getElementById('spellInput');
            const submitBtn = document.getElementById('submitBtn');
            if (spellInput) {
                spellInput.disabled = false;
                spellInput.placeholder = "Type your answer...";
                spellInput.focus(); // Auto-focus for faster typing
            }
            if (submitBtn) {
                submitBtn.disabled = false;
            }
        };
        utterance.onerror = () => {
            visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
            status.textContent = '‚ö†Ô∏è Voice error';
            
            // Unlock input even on error (fair play)
            const spellInput = document.getElementById('spellInput');
            const submitBtn = document.getElementById('submitBtn');
            if (spellInput) {
                spellInput.disabled = false;
                spellInput.placeholder = "Type your answer...";
                spellInput.focus();
            }
            if (submitBtn) {
                submitBtn.disabled = false;
            }
        };

        // Natural pauses and word pulses with 150ms word spacing
        utterance.onboundary = (event) => {
            if (event.name === 'word' || event.charLength > 0) {
                // Word boundary - add micro-pause
                visualizer.classList.remove('speaking');
                visualizer.classList.add('pausing', 'word-pulse');
                
                // Resume speaking after 150ms pause (natural word spacing)
                setTimeout(() => {
                    visualizer.classList.remove('pausing', 'word-pulse');
                    visualizer.classList.add('speaking');
                }, 150);
            }
            
            // Sentence boundaries - longer pause
            const char = (utterance.text || '').charAt(event.charIndex);
            if (char === ',' || char === ';' || char === '.' || char === '!' || char === '?') {
                visualizer.classList.remove('speaking');
                visualizer.classList.add('pausing');
                setTimeout(() => {
                    visualizer.classList.remove('pausing');
                    visualizer.classList.add('speaking');
                }, 400);
            }
        };

        speechSynthesis.speak(utterance);
        
        // iOS fallback - reload voices if empty
        if (speechSynthesis.getVoices().length === 0) {
            speechSynthesis.addEventListener('voiceschanged', () => {
                const voices = speechSynthesis.getVoices();
                const voice = voices.find(v => v.lang.startsWith('en'));
                if (voice && !utterance.voice) {
                    utterance.voice = voice;
                    cachedVoice = voice;
                }
            }, { once: true });
        }
    }, 100); // iOS Fix: 100ms delay
}

async function submitAnswer(isSkip = false) {
    const userInput = document.getElementById('spellInput').value.trim();
    
    if (!userInput && !isSkip) {
        alert('Please enter your answer!');
        return;
    }

    // Stop timer
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }

    const elapsedTime = Date.now() - wordStartTime;

    try {
        // iOS Fix: Add timeout to prevent hanging POST requests
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        
        const response = await fetch('/api/speed-round/answer', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                user_input: userInput || '',
                elapsed_ms: elapsedTime,
                skipped: isSkip
            }),
            signal: controller.signal
        });
        clearTimeout(timeoutId);

        // iOS Fix: Check response status before parsing JSON
        if (!response.ok) {
            throw new Error(`Server error: ${response.status}`);
        }

        const data = await response.json();

        if (data.error) {
            alert('Error: ' + data.error);
            return;
        }

        // Show feedback
        showFeedback(data.is_correct, data.points_earned, data.correct_spelling);

        // Update stats from response
        currentStreak = data.current_streak;
        totalPoints = data.total_points;
        updateStats();

        // Highlight streak if it increased
        if (data.is_correct && currentStreak > 0) {
            highlightStat('streakBox');
        }

        // Highlight points if earned
        if (data.points_earned > 0) {
            highlightStat('pointsBox');
        }

        // Load next word after delay
        setTimeout(() => {
            if (data.complete) {
                completeRound();
            } else {
                loadNextWord();
            }
        }, 1500);

    } catch (error) {
        console.error('‚ùå Error submitting answer:', error);
        
        // iOS-specific error handling
        if (error.name === 'AbortError') {
            alert('‚è±Ô∏è Connection timeout. Your answer wasn\'t submitted. Please check your connection.');
        } else {
            alert('‚ùå Failed to submit answer: ' + error.message);
        }
        
        // Restart timer to give user another chance
        wordStartTime = Date.now();
        startTimer();
    }
}

    } catch (error) {
        console.error('Error submitting answer:', error);
        alert('Failed to submit answer. Please try again.');
    }
}

function showFeedback(isCorrect, points, correctSpelling) {
    try { window.BeeVoiceViz?.react(isCorrect ? 'feedback-correct' : 'feedback-incorrect'); } catch (e) {}

    // Speak a short friendly feedback phrase (kept brief for speed round pacing)
    const congrats = [
        'Great job!',
        'Well done!',
        'Excellent!',
        'Nice work!',
        'You got it!'
    ];
    const gentle = [
        "Good try.",
        "Almost. You'll get the next one.",
        "Keep going, you can do it.",
        "No worries, try the next one.",
        "Shake it off and try again."
    ];
    const phrase = isCorrect ? congrats[Math.floor(Math.random()*congrats.length)]
                             : gentle[Math.floor(Math.random()*gentle.length)];
    (function speakQuick(text){
        try {
            if (!('speechSynthesis' in window)) return;
            // cancel any overlap, keep it snappy
            speechSynthesis.cancel();
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 1.0; u.pitch = 1.1; u.volume = 0.9;
            if (typeof cachedVoice !== 'undefined' && cachedVoice) u.voice = cachedVoice;
            const viz = document.getElementById('voiceVisualizer');
            const status = document.getElementById('voiceStatus');
            u.onstart = ()=>{ viz?.classList.add('speaking'); if(status) status.textContent='üéôÔ∏è Speaking'; };
            u.onend = async ()=>{
                // ~20% of the time, follow with the student's name as a separate utterance after a brief pause
                const doName = !!studentName && Math.random() < 0.20;
                if (doName) {
                    viz?.classList.remove('speaking');
                    viz?.classList.add('pausing');
                    await new Promise(r=>setTimeout(r, 360));
                    viz?.classList.remove('pausing');
                    const n = new SpeechSynthesisUtterance(studentName);
                    n.rate = 1.0; n.pitch = 1.12; n.volume = 0.95;
                    if (typeof cachedVoice !== 'undefined' && cachedVoice) n.voice = cachedVoice;
                    n.onstart = ()=>{ viz?.classList.add('speaking'); if(status) status.textContent='üéôÔ∏è Speaking'; };
                    n.onend = ()=>{ viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready'; };
                    n.onerror = ()=>{ viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready'; };
                    speechSynthesis.speak(n);
                    return;
                }
                viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready';
            };
            u.onerror = ()=>{ viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready'; };
            speechSynthesis.speak(u);
        } catch {}
    })(phrase);
    const feedback = document.createElement('div');
    feedback.className = `feedback-message ${isCorrect ? 'correct' : 'incorrect'}`;
    
    const icon = isCorrect ? '‚úì' : '‚úó';
    const text = isCorrect ? 'Correct!' : 'Incorrect';
    const color = isCorrect ? '#4CAF50' : '#FF4444';
    
    let subtext = isCorrect ? `+${points} points!` : `Correct spelling: ${correctSpelling}`;
    
    feedback.innerHTML = `
        <div class="feedback-icon" style="color: ${color};">${icon}</div>
        <div class="feedback-text" style="color: ${color};">${text}</div>
        <div class="feedback-subtext" style="color: ${color};">${subtext}</div>
    `;
    
    document.body.appendChild(feedback);
    
    setTimeout(() => {
        feedback.style.animation = 'feedbackPop 0.3s ease reverse';
        setTimeout(() => feedback.remove(), 300);
    }, 1200);
}

function highlightStat(boxId) {
    const box = document.getElementById(boxId);
    box.classList.add('highlight');
    setTimeout(() => box.classList.remove('highlight'), 1000);
}

async function completeRound() {
    // Announce end of quiz before redirecting
    try {
        if ('speechSynthesis' in window) {
            speechSynthesis.cancel();
            const msg = new SpeechSynthesisUtterance("That's the end of the quiz. Please wait for your quiz results.");
            msg.rate = 1.0; msg.pitch = 1.1; msg.volume = 0.95;
            if (typeof cachedVoice !== 'undefined' && cachedVoice) msg.voice = cachedVoice;
            const viz = document.getElementById('voiceVisualizer');
            const status = document.getElementById('voiceStatus');
            msg.onstart = ()=>{ viz?.classList.add('speaking'); if(status) status.textContent='üéôÔ∏è Speaking'; };
            msg.onend = ()=>{ viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready'; };
            msg.onerror = ()=>{ viz?.classList.remove('speaking','pausing','word-pulse'); if(status) status.textContent='üêù Ready'; };
            speechSynthesis.speak(msg);
            // small wait so the user hears it before we navigate
            await new Promise(r=>setTimeout(r, 1200));
        }
    } catch {}

    // Show loading
    document.getElementById('loadingOverlay').style.display = 'flex';

    try {
        const response = await fetch('/api/speed-round/complete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' }
        });

        const data = await response.json();

        if (data.error) {
            alert('Error: ' + data.error);
            window.location.href = '/speed-round/setup';
            return;
        }

        // Redirect to results page
        window.location.href = '/speed-round/results';

    } catch (error) {
        console.error('Error completing round:', error);
        alert('Failed to complete round. Redirecting to setup...');
        window.location.href = '/speed-round/setup';
    }
}

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    // Cancel any ongoing speech
    if (speechSynthesis) {
        speechSynthesis.cancel();
    }
});

// ‚ö†Ô∏è ERROR BOUNDARY HELPERS ‚ö†Ô∏è
function showErrorBoundary(title, message, showRetry) {
    // Set default value if not provided
    if (typeof showRetry === 'undefined') {
        showRetry = false;
    }
    
    const errorBoundary = document.getElementById('errorBoundary');
    const errorTitle = document.getElementById('errorTitle');
    const errorMessage = document.getElementById('errorMessage');
    const errorRetryBtn = document.getElementById('errorRetryBtn');
    
    if (!errorBoundary) {
        console.error('‚ùå Error boundary element not found');
        alert(title + ': ' + message);
        return;
    }
    
    if (errorTitle) errorTitle.textContent = title;
    if (errorMessage) errorMessage.textContent = message;
    if (errorRetryBtn) errorRetryBtn.style.display = showRetry ? 'inline-block' : 'none';
    
    errorBoundary.style.display = 'flex';
    
    // Stop timer if running
    if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    
    // Cancel speech
    if (speechSynthesis) {
        speechSynthesis.cancel();
    }
}

function retrySpeedRound() {
    const errorBoundary = document.getElementById('errorBoundary');
    if (errorBoundary) {
        errorBoundary.style.display = 'none';
    }
    
    // Reset state
    currentWord = null;
    timeRemaining = 0;
    
    // Try to reload
    try {
        loadNextWord();
    } catch (error) {
        console.error('‚ùå Retry failed:', error);
        showErrorBoundary(
            'Retry Failed',
            'Still unable to load Speed Round. Please check your connection and try again from setup.',
            false
        );
    }
}

// Global error handler for uncaught errors
window.addEventListener('error', (event) => {
    console.error('‚ùå Global error caught:', event.error);
    if (event.error && event.error.message && event.error.message.includes('avatar')) {
        // Avatar loading errors are non-critical, just log them
        console.warn('‚ö†Ô∏è Avatar loading issue (non-critical):', event.error);
        event.preventDefault(); // Prevent default error handling
        return;
    }
    // For other errors, show error boundary
    showErrorBoundary(
        'Unexpected Error',
        'Something went wrong. Please try reloading or return to setup.',
        true
    );
});
// ------- end of main Speed Round logic -------
</script>

<!-- Dotted ribbon JS with speech-state awareness -->
<script>
(function(){
    const canvas = document.getElementById('dotWaveCanvas');
    if (!canvas) return;
    const ctx = canvas.getContext('2d');

    let W = canvas.width;
    let H = canvas.height;
    let DPR = window.devicePixelRatio || 1;

    function resizeCanvas(){
        DPR = window.devicePixelRatio || 1;
        const cssWidth = canvas.clientWidth || 500;
        const cssHeight = canvas.clientHeight || 160;
        canvas.width = Math.round(cssWidth * DPR);
        canvas.height = Math.round(cssHeight * DPR);
        canvas.style.width = cssWidth + 'px';
        canvas.style.height = cssHeight + 'px';
        W = canvas.width; H = canvas.height;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const VZ = window.BeeSmartVoiceVizCfg || {};
    const pick = (v, d) => (v !== undefined && v !== null) ? v : d;
    const MAX_WAVES = pick(VZ.MAX_WAVES, 6); // maximum; will collapse to one during pauses
    let wavePack = 1;     // 1 => draw all waves, 0 => only one
    let wavePackTarget = 1;
    const DOTS_PER_WAVE = pick(VZ.DOTS_PER_WAVE, 56); // more points for definition
    const DOT_RADIUS = pick(VZ.DOT_RADIUS, 3);
    const WAVE_SPACING = pick(VZ.WAVE_SPACING, 20);  // slightly larger spacing for clarity
    const HORIZONTAL_PAD_CSS = pick(VZ.HORIZONTAL_PAD_CSS, 12); // reduce buffer so lines are longer

    const waveColors = VZ.waveColors || ['#6bff6b','#a6ff3a','#ffee33','#ffb62b','#ff7a1f','#ff3a2a'];

    let mode = 'idle';
    const ET = VZ.energyTargets || {};
    let energyTarget = pick(ET.idle, 0.04);
    let energy = energyTarget;
    let dipBoost = 0;    // down emphasis on pause start
    let surgeBoost = 0;  // up emphasis on speak start

    function setMode(next){
        if (mode !== next) {
            if (next === 'pausing') dipBoost = 1;
            if (next === 'speaking') surgeBoost = 1;
        }
        mode = next;
        // Expand waves when speaking; collapse to one when paused/idle
        wavePackTarget = (mode === 'speaking') ? 1 : 0;
    if (mode === 'speaking') energyTarget = pick(ET.speaking, 1.0);
    else if (mode === 'pausing') energyTarget = pick(ET.pausing, 0.06);
    else energyTarget = pick(ET.idle, 0.04);
    }
    window.voiceVizSetMode = setMode;

    const host = document.getElementById('voiceVisualizer');
    if (host && 'MutationObserver' in window){
        const mo = new MutationObserver(() => {
            const c = host.classList;
            if (c.contains('speaking')) setMode('speaking');
            else if (c.contains('pausing')) setMode('pausing');
            else setMode('idle');
        });
        mo.observe(host, { attributes: true, attributeFilter: ['class'] });
    }

    // Lightweight helper to trigger quick visual reactions from UI events (parity with quiz page)
    window.BeeVoiceViz = (function(){
        function hostEl(){ return document.getElementById('voiceVisualizer'); }
        function speak(ms=600){ const h=hostEl(); if(!h) return; h.classList.add('speaking'); setTimeout(()=>h.classList.remove('speaking'), ms); }
        function pulse(ms=220){ const h=hostEl(); if(!h) return; h.classList.add('pausing','word-pulse'); setTimeout(()=>h.classList.remove('pausing','word-pulse'), ms); }
        function react(kind){
            switch(kind){
                case 'button': return pulse(200);
                case 'submit': return speak(480);
                case 'hint': return pulse(260);
                case 'skip': return pulse(300);
                case 'feedback-correct': return speak(700);
                case 'feedback-incorrect': return pulse(520);
                default: return pulse(180);
            }
        }
        return { speak, pulse, react };
    })();

        function getEnergy(t){
        const fake = 0.5 + 0.5*Math.sin(t*0.002) + 0.25*Math.sin(t*0.005 + 2);
        return Math.max(0, Math.min(1, fake));
    }

    function drawFrame(t){
            const base = getEnergy(t);
            const E = VZ.easing || {};
            const ENERGY_EASE = pick(E.energy, 0.18);
            const WAVEPACK_EASE = pick(E.wavePack, 0.22);
            const DIP_DECAY = pick(E.dipDecay, 0.15);
            const SURGE_DECAY = pick(E.surgeDecay, 0.10);
            const B = VZ.boostScales || {};
            const DIP_SCALE = pick(B.dip, 0.65);
            const SURGE_SCALE = pick(B.surge, 0.15);
            const SH = VZ.waveShape || {};
        energy += (energyTarget - energy) * ENERGY_EASE;
        // Ease the number of visible waves toward target (1 or many)
        wavePack += (wavePackTarget - wavePack) * WAVEPACK_EASE;
        dipBoost += (0 - dipBoost) * DIP_DECAY;
        surgeBoost += (0 - surgeBoost) * SURGE_DECAY;
        const motionScale = (1 - DIP_SCALE * dipBoost) * (1 + SURGE_SCALE * surgeBoost);
            const drive = base * energy * motionScale;

        ctx.clearRect(0,0,W,H);

        // Precompute horizontal padding and optional L-R gradient overlay
        const pad = HORIZONTAL_PAD_CSS * DPR;
        const GR = VZ.gradientLR || {};
        let grad = null;
        if (GR.enabled) {
            grad = ctx.createLinearGradient(pad, 0, W - pad, 0);
            const stops = GR.stops || [];
            for (let s = 0; s < stops.length; s++) {
                const st = stops[s] || {};
                const off = (typeof st.offset === 'number') ? st.offset : (s/(Math.max(1,stops.length-1)));
                const col = st.color || '#ffffff';
                grad.addColorStop(off, col);
            }
        }

        // End-fade configuration (transparent at both ends)
        const EF = VZ.endFade || {};
        const EF_ENABLED = (EF.enabled !== undefined) ? !!EF.enabled : true;
        const fadeFrac = (typeof EF.fraction === 'number') ? Math.max(0, Math.min(0.5, EF.fraction)) : 0.16;
        const drawableWidth = Math.max(1, (W - 2*pad));
        const fadeWidth = Math.max(8 * DPR, fadeFrac * drawableWidth);
        function edgeFadeAlpha(x){
            if (!EF_ENABLED) return 1;
            const leftDist = x - pad;
            const rightDist = (pad + drawableWidth) - x;
            const d = Math.max(0, Math.min(leftDist, rightDist));
            const u = Math.max(0, Math.min(1, d / fadeWidth));
            return 0.5 - 0.5 * Math.cos(Math.PI * u);
        }

        const wavesToDraw = Math.max(1, Math.round(1 + (MAX_WAVES-1) * wavePack));
        // Clip to safe drawable area to ensure visuals stay inside the card border
        ctx.save();
        ctx.beginPath();
        ctx.rect(pad, 0, W - 2*pad, H);
        ctx.clip();
        for (let w = 0; w < wavesToDraw; w++) {
            const color = waveColors[w % waveColors.length];
            const yOffset = -w * WAVE_SPACING;

            for (let i = 0; i < DOTS_PER_WAVE; i++) {
                const progress = i / (DOTS_PER_WAVE - 1);
                const x = progress * (W - 2*pad) + pad;

                const freq = pick(SH.baseFreq, 2) + w * pick(SH.freqStep, 0.4);
                const phase = t*0.004 + w*0.6;
                let amp = (pick(SH.ampBase, 28) + w*pick(SH.ampStep, 8)) * drive; // INCREASED: More pronounced peaks (was 12 and 4)

                // Edge tip pinch: collapse amplitude and spacing near edges so waves meet
                const TP = VZ.tipPinch || {};
                let pinch = 1;
                if (TP.enabled) {
                    const p = (typeof TP.power === 'number') ? TP.power : 1.25;
                    pinch = Math.pow(Math.sin(Math.PI * progress), Math.max(0.8, Math.min(2.0, p)));
                    amp *= pinch;
                }

                // Thickness bulge across X to enhance ribbon look
                const TB = VZ.thicknessBulge || {};
                if (TB.enabled) {
                    const bulgeMag = (typeof TB.magnitude === 'number') ? TB.magnitude : 0.18;
                    const bulgeSpeed = (typeof TB.speed === 'number') ? TB.speed : 0.002;
                    const bulgeCycles = (typeof TB.cycles === 'number') ? TB.cycles : 1.2;
                    const bulge = 1 + bulgeMag * Math.sin(progress * Math.PI * 2 * bulgeCycles + t * bulgeSpeed * 1000);
                    amp *= bulge;
                }

                const mainWaveY = Math.sin(progress * freq * Math.PI + phase) * amp;
                const ripple = Math.sin(progress * pick(SH.rippleFreq, 12) + t*0.01 + w) * (pick(SH.rippleBase, 3) + w) * (0.5 + 0.5*drive);
                const y = (H/2 + 20*DPR) + (yOffset * pinch) + mainWaveY + ripple;

                const edgeA = edgeFadeAlpha(x);
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.shadowColor = color;
                ctx.shadowBlur = 3 * edgeA; // REDUCED: Remove halo effect (was 12)
                const prevAlpha = ctx.globalAlpha;
                ctx.globalAlpha = edgeA;
                ctx.arc(x, y, DOT_RADIUS, 0, Math.PI*2);
                ctx.fill();
                ctx.closePath();

                if (grad) {
                    const alpha = (typeof GR.alpha === 'number') ? GR.alpha : 0.45;
                    const savedAlpha = ctx.globalAlpha;
                    const prevShadow = ctx.shadowBlur;
                    ctx.globalAlpha = edgeA * alpha;
                    ctx.shadowBlur = 0;
                    ctx.beginPath();
                    ctx.fillStyle = grad;
                    ctx.arc(x, y, DOT_RADIUS, 0, Math.PI*2);
                    ctx.fill();
                    ctx.closePath();
                    ctx.globalAlpha = savedAlpha;
                    ctx.shadowBlur = prevShadow;
                }
                ctx.globalAlpha = prevAlpha;
            }
    }
    ctx.restore();

        // Soft central glow with horizontal taper (matches Quiz)
        const CG = VZ.centerGlow || {};
        if (CG.enabled) {
            const baseAlpha = (typeof CG.alpha === 'number') ? CG.alpha : 0.15; // REDUCED: Less glow/halo (was 0.5)
            const span = (typeof CG.verticalSpan === 'number') ? Math.max(0.1, Math.min(1, CG.verticalSpan)) : 0.55;
            const energyScale = (typeof CG.energyScale === 'number') ? CG.energyScale : 0.9;
            const horizFrac = (typeof CG.horizontalFraction === 'number') ? Math.max(0, Math.min(0.5, CG.horizontalFraction)) : 0.15;
            const glowAlpha = baseAlpha * Math.max(0, Math.min(1, energy * energyScale));
            const drawableWidth2 = Math.max(1, (W - 2*pad));
            const feather = Math.max(8 * DPR, horizFrac * drawableWidth2);
            if (glowAlpha > 0.01) {
                // Draw vertical glow into an offscreen canvas
                const off = document.createElement('canvas');
                off.width = W; off.height = H;
                const ox = off.getContext('2d');
                const top = (H*(1-span))/2;
                const bottom = H - top;
                const gradY = ox.createLinearGradient(0, top, 0, bottom);
                gradY.addColorStop(0.0, 'rgba(255,255,255,0)');
                gradY.addColorStop(0.5, 'rgba(255,255,255,1)');
                gradY.addColorStop(1.0, 'rgba(255,255,255,0)');
                ox.fillStyle = gradY;
                ox.fillRect(pad, top, W - 2*pad, bottom - top);

                // Mask with horizontal taper using destination-in
                const gradX = ox.createLinearGradient(pad, 0, W - pad, 0);
                const leftStop = pad + feather;
                const rightStop = (W - pad) - feather;
                const lOff = Math.max(0, Math.min(1, (leftStop - pad) / drawableWidth2));
                const rOff = Math.max(0, Math.min(1, (rightStop - pad) / drawableWidth2));
                gradX.addColorStop(0, 'rgba(0,0,0,0)');
                gradX.addColorStop(lOff, 'rgba(0,0,0,1)');
                gradX.addColorStop(rOff, 'rgba(0,0,0,1)');
                gradX.addColorStop(1, 'rgba(0,0,0,0)');
                ox.globalCompositeOperation = 'destination-in';
                ox.fillStyle = gradX;
                ox.fillRect(pad, 0, W - 2*pad, H);

                // Blend back onto main
                const prevComp = ctx.globalCompositeOperation;
                const prevAlpha2 = ctx.globalAlpha;
                ctx.globalCompositeOperation = 'lighter';
                ctx.globalAlpha = glowAlpha;
                ctx.drawImage(off, 0, 0);
                ctx.globalCompositeOperation = prevComp;
                ctx.globalAlpha = prevAlpha2;
            }
        }
        requestAnimationFrame(drawFrame);
    }

    setMode('idle');
    requestAnimationFrame(drawFrame);
})();
</script>
{% endblock %}
