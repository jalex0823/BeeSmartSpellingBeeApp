{% extends "base.html" %}

{% block title %}BeeSmart Quiz - Practice Your Spelling{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/BeeSmart.css') }}">
<style>
    .quiz-container {
        max-width: 500px;
        margin: 0 auto;
        text-align: center;
        padding: 1.5rem 1rem 5rem;
        position: relative;
    }
    
    /* Progress tracker fixed at bottom of viewport */
    .progress-tracker {
        position: fixed !important;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        padding: 0;
        background: none;
        border: none;
        box-shadow: none;
        pointer-events: none;
    }
    
    .progress-tracker .honey-jar {
        position: relative;
        width: 65px;
        height: 80px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 70%);
        border: 3px solid rgba(150, 110, 20, 0.8);
        border-radius: 14px 14px 18px 18px;
        backdrop-filter: blur(3px);
        box-shadow: 0 0 20px rgba(255, 193, 7, 0.6);
        overflow: hidden;
        animation: honeyJarGlow 3s ease-in-out infinite;
        margin: 0 auto 0.6rem auto;
        flex-shrink: 0;
        pointer-events: auto;
    }
    
    .progress-tracker .honey-jar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 6px;
        right: 6px;
        height: 7px;
        border-radius: 0 0 6px 6px;
        background: linear-gradient(180deg, #FFCC80 0%, #FB8C00 100%);
        box-shadow: 0 2px 8px rgba(251, 140, 0, 0.5);
    }
    
    .progress-description {
        font-size: 0.85rem;
        font-weight: 600;
        color: #5d4100;
        text-align: center;
        margin-top: 0.4rem;
        line-height: 1.4;
        width: 100%;
    }

    .quiz-header {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        background: rgba(255, 255, 255, 0.88);
        border-radius: 20px;
        padding: 1.5rem;
        box-shadow: 0 12px 25px rgba(255, 193, 7, 0.25);
        border: 2px solid rgba(255, 193, 7, 0.35);
        margin-bottom: 1.5rem;
    }
    
    /* Honey Jar centered at top */
    .honey-jar-top {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        margin-bottom: 0.5rem;
    }
    
    .honey-jar-top .honey-jar {
        position: relative;
        width: 60px;
        height: 75px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 70%);
        border: 3px solid rgba(150, 110, 20, 0.8);
        border-radius: 14px 14px 18px 18px;
        backdrop-filter: blur(3px);
        box-shadow: 0 0 20px rgba(255, 193, 7, 0.6);
        overflow: hidden;
        animation: honeyJarGlow 3s ease-in-out infinite;
        margin-bottom: 0.6rem;
    }

    .progress-info {
        display: flex;
        flex-direction: column;
        align-items: center;
        color: #5d4100;
        font-size: 1.15rem;
        font-weight: 700;
        gap: 0.8rem;
        width: 100%;
    }

    .progress-text {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.6rem;
        width: 100%;
    }
    
    /* Fun back arrow button */
    .back-button {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        padding: 0.5rem 1rem;
        background: linear-gradient(135deg, #FFE082 0%, #FFD54F 100%);
        color: #5d4100;
        text-decoration: none;
        font-weight: 700;
        font-size: 0.95rem;
        border-radius: 20px;
        border: 2px solid rgba(255, 193, 7, 0.5);
        box-shadow: 0 4px 12px rgba(255, 193, 7, 0.3);
        transition: all 0.3s ease;
        cursor: pointer;
    }
    
    .back-button:hover {
        background: linear-gradient(135deg, #FFD54F 0%, #FFC107 100%);
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 6px 18px rgba(255, 193, 7, 0.45);
    }
    
    .back-button .arrow {
        font-size: 1.3rem;
        transition: transform 0.3s ease;
    }
    
    .back-button:hover .arrow {
        transform: translateX(-4px);
    }
    
    /* Old inline honey jar styles (keeping for compatibility) */
    .honey-jar-inline {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
    }
    
    .honey-jar-inline .honey-jar {
        position: relative;
        width: 50px;
        height: 65px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 70%);
        border: 3px solid rgba(150, 110, 20, 0.8);
        border-radius: 12px 12px 16px 16px;
        backdrop-filter: blur(3px);
        box-shadow: 0 0 16px rgba(255, 193, 7, 0.5);
        overflow: hidden;
        animation: honeyJarGlow 3s ease-in-out infinite;
    }
    
    .honey-jar-inline .honey-jar::before {
        content: '';
        position: absolute;
        top: 0;
        left: 5px;
        right: 5px;
        height: 6px;
        border-radius: 0 0 5px 5px;
        background: linear-gradient(180deg, #FFCC80 0%, #FB8C00 100%);
        box-shadow: 0 2px 6px rgba(251, 140, 0, 0.4);
    }
    
    .honey-jar-inline .honey-jar-label {
        font-size: 0.65rem;
        font-weight: 600;
        color: #B8860B;
        text-align: center;
        margin-top: 0.25rem;
        background: rgba(255, 255, 255, 0.9);
        padding: 0.15rem 0.4rem;
        border-radius: 6px;
        border: 1px solid rgba(255, 193, 7, 0.3);
        box-shadow: 0 2px 4px rgba(255, 193, 7, 0.2);
        white-space: nowrap;
    }

    .progress-info a {
        color: #2b2100;
        text-decoration: none;
        font-weight: 700;
        font-size: 0.9rem;
    }

    .score-display {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .score-item {
        flex: 0 1 auto;
        min-width: 85px;
        max-width: 110px;
        background: rgba(255, 255, 255, 0.88);
        border-radius: 12px;
        padding: 0.6rem 0.8rem;
        border: 1px solid rgba(255, 213, 79, 0.6);
        box-shadow: 0 6px 12px rgba(255, 193, 7, 0.15);
        text-align: center;
        position: relative;
    }

    /* Remove old honey jar overlay styles */
    .streak-with-honey {
        position: relative;
    }
    
    @keyframes honeyJarGlow {
        0%, 100% { 
            box-shadow: 0 0 16px rgba(255, 193, 7, 0.5);
            transform: scale(1);
        }
        50% { 
            box-shadow: 0 0 20px rgba(255, 193, 7, 0.7);
            transform: scale(1.02);
        }
    }

    .score-number {
        font-size: 1.6rem;
        font-weight: 700;
        display: block;
        margin-bottom: 0.2rem;
    }

    .score-label {
        font-size: 0.75rem;
        color: #a57300;
        letter-spacing: 0.02em;
        text-transform: uppercase;
    }

    .score-number.correct { color: #4CAF50; }
    .score-number.incorrect { color: #FF7043; }
    .score-number.streak { color: #FBC02D; }

    .definition-display {
        font-size: 1.15rem;
        margin-bottom: 1.8rem;
        padding: 1.5rem;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 18px;
        border: 2px dashed rgba(255, 193, 7, 0.6);
        color: #6d4c00;
        box-shadow: inset 0 0 14px rgba(255, 193, 7, 0.18);
        line-height: 1.6;
        text-align: left;
    }
    
    /* Dictionary-style definition formatting */
    .definition-display .pronunciation {
        font-family: 'Courier New', monospace;
        color: #666;
        font-size: 0.95rem;
        margin-bottom: 0.5rem;
        display: block;
    }
    
    .definition-display .word-type {
        display: inline-block;
        background: linear-gradient(135deg, #E8A87C 0%, #C27BA0 100%);
        color: white;
        padding: 0.2rem 0.8rem;
        border-radius: 12px;
        font-size: 0.85rem;
        font-weight: 600;
        text-transform: uppercase;
        margin-bottom: 0.75rem;
    }
    
    .definition-display .word-definition {
        font-weight: 500;
        color: #2C3E50;
        margin-bottom: 1rem;
        display: block;
        line-height: 1.7;
        font-size: 1.1rem;
    }
    
    .definition-display .definition-number {
        font-weight: 700;
        color: #E8A87C;
        margin-right: 0.5rem;
    }
    
    .definition-display .sentence-example {
        font-style: italic;
        color: #5D6D7E;
        display: block;
        margin-top: 0.75rem;
        padding: 0.75rem 1rem;
        background: rgba(232, 168, 124, 0.08);
        border-left: 3px solid #E8A87C;
        border-radius: 0 8px 8px 0;
        line-height: 1.6;
    }
    
    .definition-display .example-label {
        font-weight: 600;
        color: #C27BA0;
        font-style: normal;
        margin-right: 0.5rem;
    }
    
    .definition-display .blank-word {
        display: inline-block;
        min-width: 80px;
        border-bottom: 2px solid #E8A87C;
        text-align: center;
        padding: 0 0.5rem;
        font-weight: 700;
        color: #C27BA0;
    }
    
    .definition-display .similar-words {
        margin-top: 1rem;
        padding-top: 0.75rem;
        border-top: 1px dashed rgba(232, 168, 124, 0.3);
        font-size: 0.9rem;
        color: #7F8C8D;
    }
    
    .definition-display .similar-label {
        font-weight: 600;
        color: #95A5A6;
    }
    
    .definition-display .similar-word {
        display: inline-block;
        background: rgba(232, 168, 124, 0.15);
        padding: 0.25rem 0.6rem;
        border-radius: 12px;
        margin: 0.25rem;
        color: #5D6D7E;
        font-size: 0.85rem;
    }

    /* ⏱️ Countdown Timer - Honey Jar Design */
    .countdown-container {
        display: flex;
        justify-content: center;
        margin: 1rem 0 1.5rem;
        opacity: 0;
        transform: translateY(-10px);
        transition: opacity 0.3s ease, transform 0.3s ease;
    }
    
    .countdown-container.active {
        opacity: 1;
        transform: translateY(0);
    }
    
    .countdown-container.hidden {
        display: none;
    }
    
    .honey-jar-timer {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
    }
    
    .jar-outline {
        position: relative;
        width: 80px;
        height: 100px;
        background: linear-gradient(180deg, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.2) 70%);
        border: 3px solid rgba(150, 110, 20, 0.85);
        border-radius: 16px 16px 20px 20px;
        backdrop-filter: blur(5px);
        box-shadow: 0 4px 16px rgba(255, 193, 7, 0.4), inset 0 2px 8px rgba(255, 255, 255, 0.3);
        overflow: hidden;
        transition: all 0.3s ease;
    }
    
    /* Jar lid */
    .jar-outline::before {
        content: '';
        position: absolute;
        top: 0;
        left: 8px;
        right: 8px;
        height: 8px;
        border-radius: 0 0 8px 8px;
        background: linear-gradient(180deg, #FFCC80 0%, #FB8C00 100%);
        box-shadow: 0 2px 8px rgba(251, 140, 0, 0.6);
        z-index: 5;
    }
    
    .honey-fill {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(180deg, #FFD700 0%, #FFA500 60%, #FF8C00 100%);
        transition: height 0.3s linear;
        border-radius: 0 0 16px 16px;
        box-shadow: inset 0 2px 12px rgba(255, 255, 255, 0.4);
        animation: honeyShimmer 2s ease-in-out infinite;
    }
    
    @keyframes honeyShimmer {
        0%, 100% { 
            filter: brightness(1); 
        }
        50% { 
            filter: brightness(1.15);
        }
    }
    
    /* Honey bubbles */
    .honey-bubbles {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        height: 100%;
        pointer-events: none;
        z-index: 2;
    }
    
    .bubble {
        position: absolute;
        width: 4px;
        height: 4px;
        background: rgba(255, 255, 255, 0.6);
        border-radius: 50%;
        animation: bubbleRise 3s ease-in-out infinite;
    }
    
    .bubble:nth-child(1) {
        left: 20%;
        animation-delay: 0s;
    }
    
    .bubble:nth-child(2) {
        left: 50%;
        animation-delay: 1s;
        animation-duration: 3.5s;
    }
    
    .bubble:nth-child(3) {
        left: 75%;
        animation-delay: 2s;
        animation-duration: 4s;
    }
    
    @keyframes bubbleRise {
        0% {
            bottom: 5%;
            opacity: 0;
            transform: scale(0.8);
        }
        20% {
            opacity: 1;
        }
        100% {
            bottom: 95%;
            opacity: 0;
            transform: scale(1.2);
        }
    }
    
    .timer-number {
        font-size: 2rem;
        font-weight: 800;
        color: #5d4100;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: color 0.3s ease, transform 0.2s ease;
        min-width: 50px;
        text-align: center;
    }
    
    .timer-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: #6d4c00;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }
    
    /* Warning state (5 seconds left) */
    .honey-jar-timer.warning .jar-outline {
        border-color: rgba(255, 152, 0, 0.9);
        box-shadow: 0 4px 20px rgba(255, 152, 0, 0.6), inset 0 2px 8px rgba(255, 255, 255, 0.3);
        animation: jarPulseWarning 0.8s ease-in-out infinite;
    }
    
    .honey-jar-timer.warning .honey-fill {
        background: linear-gradient(180deg, #FF9800 0%, #FF6F00 60%, #E65100 100%);
    }
    
    .honey-jar-timer.warning .timer-number {
        color: #FF6F00;
        transform: scale(1.05);
    }
    
    @keyframes jarPulseWarning {
        0%, 100% { 
            transform: scale(1); 
        }
        50% { 
            transform: scale(1.02);
        }
    }
    
    /* Critical state (3 seconds left) */
    .honey-jar-timer.critical .jar-outline {
        border-color: rgba(244, 67, 54, 0.95);
        box-shadow: 0 4px 24px rgba(244, 67, 54, 0.7), 
                    0 0 30px rgba(244, 67, 54, 0.5),
                    inset 0 2px 8px rgba(255, 255, 255, 0.3);
        animation: jarPulseCritical 0.4s ease-in-out infinite;
    }
    
    .honey-jar-timer.critical .honey-fill {
        background: linear-gradient(180deg, #FF5722 0%, #F44336 60%, #D32F2F 100%);
        animation: honeyCriticalGlow 0.4s ease-in-out infinite;
    }
    
    .honey-jar-timer.critical .timer-number {
        color: #D32F2F;
        transform: scale(1.1);
        animation: timerShake 0.4s ease-in-out infinite;
    }
    
    @keyframes jarPulseCritical {
        0%, 100% { 
            transform: scale(1); 
        }
        50% { 
            transform: scale(1.05);
        }
    }
    
    @keyframes honeyCriticalGlow {
        0%, 100% { 
            filter: brightness(1);
        }
        50% { 
            filter: brightness(1.3);
        }
    }
    
    @keyframes timerShake {
        0%, 100% { 
            transform: scale(1.1) rotate(0deg); 
        }
        25% { 
            transform: scale(1.1) rotate(-2deg); 
        }
        75% { 
            transform: scale(1.1) rotate(2deg); 
        }
    }
    
    /* Time expired state */
    .honey-jar-timer.expired .jar-outline {
        border-color: rgba(158, 158, 158, 0.7);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        animation: none;
    }
    
    .honey-jar-timer.expired .honey-fill {
        background: rgba(200, 200, 200, 0.3);
        animation: none;
    }
    
    .honey-jar-timer.expired .timer-number {
        color: #999;
    }
    
    /* Kid-Safe Content Badge for Quiz */
    .kid-safe-badge-quiz {
        display: inline-flex;
        align-items: center;
        gap: 0.4rem;
        background: linear-gradient(135deg, #4CAF50, #66BB6A);
        color: white;
        padding: 0.4rem 0.9rem;
        border-radius: 20px;
        font-size: 0.75rem;
        font-weight: 700;
        box-shadow: 0 3px 12px rgba(76, 175, 80, 0.25);
        border: 2px solid rgba(255, 255, 255, 0.3);
        margin-top: 0.5rem;
        animation: safetyPulseQuiz 3s ease-in-out infinite;
    }
    
    .kid-safe-badge-quiz::before {
        content: '✓';
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        font-size: 0.8rem;
        font-weight: 900;
    }
    
    @keyframes safetyPulseQuiz {
        0%, 100% {
            box-shadow: 0 3px 12px rgba(76, 175, 80, 0.25);
        }
        50% {
            box-shadow: 0 4px 16px rgba(76, 175, 80, 0.4), 0 0 12px rgba(76, 175, 80, 0.2);
        }
    }
    
    /* Mobile responsiveness */
    @media (max-width: 768px) {
        .jar-outline {
            width: 65px;
            height: 85px;
        }
        
        .timer-number {
            font-size: 1.6rem;
        }
        
        .timer-label {
            font-size: 0.7rem;
        }
    }

    /* Voice Controls */
    .voice-controls {
        display: flex;
        justify-content: center;
        gap: 1rem;
        margin-bottom: 1.5rem;
    }

    .btn-repeat {
        background: linear-gradient(90deg, #66BB6A 0%, #A5D6A7 100%);
    }

    /* Voice Visualizer with Bee Theme */
    .voice-visualizer {
        background: #FFB300; /* solid amber */
        border-radius: 20px;
        padding: 1.2rem;
        margin-bottom: 1.5rem;
        position: relative;
        overflow: visible;
        box-shadow: 0 10px 26px rgba(255, 153, 0, 0.28);
        border: none; /* remove border */
        min-height: 140px;
    }

    .voice-visualizer::before { display: none; }
    
    /* Animated Bee Mouth for Voice Visualization */
    .bee-mouth-container {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        z-index: 1;
    }
    
    .bee-face {
        position: relative;
        width: 100%;
        height: 100%;
        background: #FFD700;
        border-radius: 50%;
        border: 3px solid #FF8C00;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .bee-eyes {
        position: absolute;
        top: 25%;
        width: 100%;
        display: flex;
        justify-content: space-around;
        padding: 0 15px;
    }
    
    .bee-eye {
        width: 12px;
        height: 12px;
        background: #2C3E50;
        border-radius: 50%;
        position: relative;
    }
    
    .bee-eye::after {
        content: '';
        position: absolute;
        top: 2px;
        left: 2px;
        width: 4px;
        height: 4px;
        background: white;
        border-radius: 50%;
    }
    
    .bee-mouth {
        position: absolute;
        bottom: 20%;
        left: 50%;
        transform: translateX(-50%);
        width: 30px;
        height: 15px;
        border: 3px solid #2C3E50;
        border-top: none;
        border-radius: 0 0 20px 20px;
        transition: all 0.15s ease;
    }
    
    /* Mouth animation when speaking */
    .voice-visualizer.speaking .bee-mouth {
        animation: mouthTalk 0.3s ease-in-out infinite;
    }
    
    @keyframes mouthTalk {
        0%, 100% {
            height: 15px;
            bottom: 20%;
        }
        50% {
            height: 25px;
            bottom: 15%;
        }
    }
    
    /* Antennae */
    .bee-antennae {
        position: absolute;
        top: -10px;
        width: 100%;
        display: flex;
        justify-content: space-around;
        padding: 0 20px;
    }
    
    .bee-antenna {
        width: 2px;
        height: 15px;
        background: #FF8C00;
        position: relative;
    }
    
    .bee-antenna::after {
        content: '';
        position: absolute;
        top: -5px;
        left: 50%;
        transform: translateX(-50%);
        width: 6px;
        height: 6px;
        background: #FFD700;
        border-radius: 50%;
        border: 2px solid #FF8C00;
    }
    
    /* Animate antennae when speaking */
    .voice-visualizer.speaking .bee-antenna {
        animation: antennaBounce 0.6s ease-in-out infinite;
    }
    
    @keyframes antennaBounce {
        0%, 100% { transform: rotate(0deg); }
        25% { transform: rotate(-10deg); }
        75% { transform: rotate(10deg); }
    }
    
    .bee-antennae .bee-antenna:first-child {
        animation-delay: 0.1s;
    }
    
    .bee-antennae .bee-antenna:last-child {
        animation-delay: 0.3s;
    }

    .voice-status {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        color: #2B1B00;
        margin-bottom: 1rem;
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
    }

    /* Voice wave bars container */
    #voiceWaveContainer {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        height: 80px;
        padding: 10px;
    }

    .wave-bar {
        width: 8px;
        height: 20px;
        background: linear-gradient(180deg, #FFB347 0%, #FF8C00 100%);
        border-radius: 4px;
        opacity: 0.3;
        transition: all 0.2s ease;
    }
    
    .voice-visualizer.speaking .wave-bar {
        opacity: 1;
        animation: waveAnimation 0.6s ease-in-out infinite;
    }
    
    /* Natural pause state - amber bars stay visible with subtle animation */
    .voice-visualizer.paused .voice-wave,
    .voice-visualizer.paused .wave-bar {
        opacity: 0.7;
        animation: naturalPause 1.2s ease-in-out infinite !important;
        background: linear-gradient(to top, #FF8C00, #FFB347) !important;
        box-shadow: 0 0 8px rgba(255, 179, 71, 0.5);
    }

    /* Only animate when speaking */
    .voice-visualizer.speaking .voice-wave {
        animation: waveAnimation 0.6s ease-in-out infinite;
        background: linear-gradient(to top, #FF6B00, #FFD700) !important;
        box-shadow: 0 0 10px rgba(255, 193, 7, 0.6);
    }
    
    /* Word pulse effect - intensifies animation briefly */
    .voice-visualizer.word-pulse .voice-wave,
    .voice-visualizer.word-pulse .wave-bar {
        animation: wordPulseAnimation 0.15s ease-out;
    }
    
    /* Pausing effect - reduces animation during sentence breaks */
    .voice-visualizer.pausing .voice-wave,
    .voice-visualizer.pausing .wave-bar {
        animation: pauseAnimation 0.4s ease-in-out;
        opacity: 0.4;
    }

    /* Staggered delays for wave effect */
    .voice-visualizer.speaking .voice-wave:nth-child(1) { animation-delay: 0.3s; }
    .voice-visualizer.speaking .voice-wave:nth-child(2) { animation-delay: 0.2s; }
    .voice-visualizer.speaking .voice-wave:nth-child(3) { animation-delay: 0.1s; }
    .voice-visualizer.speaking .voice-wave:nth-child(4) { animation-delay: 0s; }      /* Center - peaks first */
    .voice-visualizer.speaking .voice-wave:nth-child(5) { animation-delay: 0.1s; }
    .voice-visualizer.speaking .voice-wave:nth-child(6) { animation-delay: 0.2s; }
    .voice-visualizer.speaking .voice-wave:nth-child(7) { animation-delay: 0.3s; }
    
    /* Height scaling - center bars taller */
    .voice-visualizer.speaking .voice-wave:nth-child(1) { animation-name: waveAnimationShort; }
    .voice-visualizer.speaking .voice-wave:nth-child(2) { animation-name: waveAnimationMedium; }
    .voice-visualizer.speaking .voice-wave:nth-child(3) { animation-name: waveAnimationTall; }
    .voice-visualizer.speaking .voice-wave:nth-child(4) { animation-name: waveAnimationTallest; } /* Center */
    .voice-visualizer.speaking .voice-wave:nth-child(5) { animation-name: waveAnimationTall; }
    .voice-visualizer.speaking .voice-wave:nth-child(6) { animation-name: waveAnimationMedium; }
    .voice-visualizer.speaking .voice-wave:nth-child(7) { animation-name: waveAnimationShort; }

    @keyframes waveAnimation {
        0%, 100% { 
            height: 20px;
            opacity: 0.8;
            transform: scaleY(1);
        }
        50% { 
            height: 55px;
            opacity: 1;
            transform: scaleY(1.2);
        }
    }
    
    /* Outer bars - shortest */
    @keyframes waveAnimationShort {
        0%, 100% { 
            height: 16px;
            opacity: 0.7;
            transform: scaleY(1);
        }
        50% { 
            height: 38px;
            opacity: 0.95;
            transform: scaleY(1.1);
        }
    }
    
    /* Mid-outer bars - medium */
    @keyframes waveAnimationMedium {
        0%, 100% { 
            height: 18px;
            opacity: 0.75;
            transform: scaleY(1);
        }
        50% { 
            height: 48px;
            opacity: 1;
            transform: scaleY(1.15);
        }
    }
    
    /* Inner bars - tall */
    @keyframes waveAnimationTall {
        0%, 100% { 
            height: 20px;
            opacity: 0.8;
            transform: scaleY(1);
        }
        50% { 
            height: 58px;
            opacity: 1;
            transform: scaleY(1.2);
        }
    }
    
    /* Center bar - tallest! */
    @keyframes waveAnimationTallest {
        0%, 100% { 
            height: 22px;
            opacity: 0.85;
            transform: scaleY(1);
        }
        50% { 
            height: 70px;
            opacity: 1;
            transform: scaleY(1.3);
        }
    }
    
    @keyframes wordPulseAnimation {
        0% { 
            height: 55px;
            opacity: 1;
            transform: scaleY(1.2);
        }
        50% { 
            height: 70px;
            opacity: 1;
            transform: scaleY(1.5);
            filter: brightness(1.3);
        }
        100% { 
            height: 55px;
            opacity: 1;
            transform: scaleY(1.2);
        }
    }
    
    @keyframes pauseAnimation {
        0% { 
            height: 55px;
            opacity: 1;
        }
        50% { 
            height: 16px;
            opacity: 0.3;
        }
        100% { 
            height: 55px;
            opacity: 1;
        }
    }

    /* Natural pause animation - gentle breathing effect in amber */
    @keyframes naturalPause {
        0%, 100% { 
            height: 18px;
            opacity: 0.7;
            transform: scaleY(1);
        }
        50% { 
            height: 28px;
            opacity: 0.85;
            transform: scaleY(1.1);
        }
    }

    @keyframes hintBounce {
        0% { 
            transform: scale(1) translateY(0);
        }
        15% { 
            transform: scale(1.05) translateY(-10px);
        }
        30% { 
            transform: scale(1) translateY(0);
        }
        45% { 
            transform: scale(1.05) translateY(-8px);
        }
        60% { 
            transform: scale(1) translateY(0);
        }
        75% { 
            transform: scale(1.03) translateY(-4px);
        }
        100% { 
            transform: scale(1) translateY(0);
        }
    }

    .hint-bounce {
        animation: hintBounce 0.8s ease-out !important;
    }

    .voice-visualizer.speaking .voice-status {
        color: #FF6B00;
        font-weight: bold;
    }

    /* Microphone icon removed - voice feedback feature coming in future version */
    .microphone-icon {
        display: none;
    }

    .feedback-area {
        min-height: 80px;
        padding: 1rem 1.5rem;
        margin: 1rem 0;
        border-radius: 18px;
        display: none;
        font-size: 1.05rem;
    }

    .feedback-area.feedback-success {
        background: rgba(76, 175, 80, 0.14);
        border: 2px solid rgba(76, 175, 80, 0.65);
        color: #2e7d32;
    }

    .feedback-area.feedback-error {
        background: rgba(255, 160, 122, 0.14);
        border: 2px solid rgba(255, 112, 67, 0.65);
        color: #bf360c;
    }
    
    @media (max-width: 768px) {
        .quiz-container {
            max-width: 100%;
            padding: 1rem 0.5rem 3rem;
        }
        
        .quiz-header {
            padding: 1rem;
        }
        
        .progress-info {
            font-size: 0.95rem;
            gap: 0.5rem;
            flex-direction: column;
            align-items: stretch;
        }
        
        .progress-tracker {
            bottom: 10px;
            padding: 0;
        }
        
        .progress-tracker .honey-jar {
            width: 55px;
            height: 70px;
            margin: 0 auto 0.6rem auto;
        }
        
        .progress-description {
            font-size: 0.8rem;
        }
        
        .progress-text {
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .back-button {
            font-size: 0.85rem;
            padding: 0.4rem 0.8rem;
        }
        
        .honey-jar-inline .honey-jar {
            width: 40px;
            height: 55px;
        }
        
        .honey-jar-inline .honey-jar-label {
            font-size: 0.6rem;
            padding: 0.1rem 0.3rem;
        }
        
        .score-display {
            gap: 0.7rem;
        }
        
        .score-item {
            min-width: 70px;
            max-width: 90px;
            padding: 0.5rem 0.6rem;
        }
        
        .score-number {
            font-size: 1.4rem;
        }
        
        .score-label {
            font-size: 0.7rem;
        }
        
        .quiz-logo .mascot-3d-container {
            width: 110px !important;
            height: 110px !important;
            margin-bottom: 1rem;
            transform: translateY(-6px);
        }
        
        .quiz-logo img {
            width: 160px;
        }
    }

    .phonetic-reveal {
        max-width: 360px;
        margin: 0.75rem auto 0;
    }

    /* Letter Hint Display */
    .letter-hint {
        max-width: 400px;
        margin: 1rem auto 0;
        padding: 1rem 1.5rem;
        background: linear-gradient(135deg, #FFF9E6 0%, #FFFBF0 100%);
        border: 2px solid #FFD700;
        border-radius: 12px;
        text-align: center;
        font-size: 1.3rem;
        font-weight: 600;
        color: #5A2C15;
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.3);
        animation: letterHintSlide 0.4s ease-out;
    }

    .letter-hint .hint-label {
        display: block;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        color: #FF8C00;
        font-weight: 700;
    }

    .letter-hint .hint-letters {
        font-family: 'Courier New', monospace;
        font-size: 2rem;
        letter-spacing: 0.5rem;
        color: #2C5F2D;
        font-weight: 700;
        text-shadow: 1px 1px 2px rgba(255, 215, 0, 0.3);
    }

    @keyframes letterHintSlide {
        0% {
            opacity: 0;
            transform: translateY(-10px);
        }
        100% {
            opacity: 1;
            transform: translateY(0);
        }
    }

    .letter-hint.hidden {
        display: none;
    }

    .quiz-buttons {
        display: flex;
        justify-content: center;
        flex-wrap: wrap;
        gap: 1rem;
        margin-top: 1.5rem;
        max-width: 400px;
        margin-left: auto;
        margin-right: auto;
    }

    .quiz-buttons .quiz-button {
        flex: 1;
        min-width: 120px;
        max-width: 180px;
    }

    .quiz-complete {
        background: rgba(255, 255, 255, 0.88);
        border-radius: 24px;
        padding: 3rem 2rem;
        border: 2px solid rgba(255, 193, 7, 0.35);
        box-shadow: 0 18px 36px rgba(255, 193, 7, 0.22);
        text-align: center;
    }

    .completion-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 1.5rem;
        margin: 2rem 0;
        /* Remove padding-bottom to let honey pot position itself */
    }
    
    /* Honey pot container - Fixed positioning with proper spacing */
    .honey-pot-container {
        text-align: center;
        background: linear-gradient(135deg, rgba(255, 250, 227, 0.95), rgba(255, 240, 245, 0.95));
        padding: 1.5rem 2rem 2rem;
        border-radius: 20px;
        box-shadow: 0 -5px 30px rgba(255, 193, 7, 0.3);
        border: 2px solid rgba(255, 193, 7, 0.4);
        margin: 3rem auto 2rem;
        max-width: 300px;
        position: relative;
        z-index: 1;
        clear: both;
        animation: slideInUp 0.8s ease 0.7s backwards;
    }

    .stat-card {
        background: rgba(255, 255, 255, 0.88);
        border-radius: 18px;
        padding: 1.5rem 1rem;
        border: 1px solid rgba(255, 213, 79, 0.6);
        box-shadow: 0 12px 20px rgba(255, 193, 7, 0.2);
    }

    @media (max-width: 768px) {
        .quiz-container {
            padding: 1.75rem 1rem 3.5rem;
        }

        .progress-info {
            flex-direction: column;
            gap: 0.75rem;
        }

        .score-item {
            min-width: 45%;
        }
    }

    /* Quiz Logo at top center */
    .quiz-logo {
        text-align: center;
        margin-bottom: 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 0.5rem;
    }
    
    /* 3D Mascot in logo section */
    .quiz-logo .mascot-3d-container {
        position: relative;
        width: 140px;
        height: 140px;
        filter: drop-shadow(0 8px 25px rgba(255, 193, 7, 0.35));
        transition: transform 0.3s ease;
        z-index: 10;
        margin-bottom: 1.2rem;
        transform: translateY(-8px);
    }
    
    .quiz-logo .mascot-3d-container:hover {
        transform: scale(1.05);
    }

    .quiz-logo img {
        width: 200px;
        height: auto;
        opacity: 0.95;
        filter: drop-shadow(0 4px 12px rgba(0, 0, 0, 0.1));
    }

    /* Version Info */
    .version-info {
        text-align: center;
        margin: 0.5rem 0 1rem 0;
    }

    .version-info small {
        color: #a57300;
        font-size: 0.75rem;
        opacity: 0.7;
        background: rgba(255, 255, 255, 0.5);
        padding: 0.25rem 0.75rem;
        border-radius: 12px;
        border: 1px solid rgba(255, 213, 79, 0.3);
    }

    /* Action Buttons - Match Main Menu Style */
    .action-btn {
        padding: 1rem 2rem;
        border: none;
        border-radius: 15px;
        font-weight: 600;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        flex: 1;
        min-width: 0;
        text-align: center;
        position: relative;
    }
    
    .action-btn:hover {
        transform: translateY(-3px) scale(1.03);
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
    }
    
    .action-btn:active {
        transform: translateY(-1px) scale(0.98);
        transition: all 0.1s ease;
    }

    /* Quiz Buttons Container */
    .quiz-buttons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        gap: 1rem;
        margin-top: 1.5rem;
    }

    .quiz-buttons .action-btn {
        width: 100%;
        min-height: 50px;
    }

    /* Exit Button Special Styling */
    .action-btn.exit {
        background: linear-gradient(90deg, #FF6B6B 0%, #FF8E8E 100%);
        color: white;
        border: 2px solid rgba(255, 107, 107, 0.6);
    }

    .action-btn.exit:hover {
        background: linear-gradient(90deg, #FF5252 0%, #FF7979 100%);
        border-color: #FF6B6B;
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
    }

    .action-btn.exit:active {
        transform: translateY(0px);
        box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
        transition: all 0.1s ease;
    }

    /* Enhanced Magical Sparkles */
    .sparkle {
        position: fixed;
        width: 16px;
        height: 16px;
        background: radial-gradient(circle, var(--sparkle-color, #FFD700) 0%, rgba(255, 255, 255, 0.8) 30%, transparent 70%);
        border-radius: 50%;
        animation: magicalSparkle 0.9s ease-out forwards;
        pointer-events: none;
        z-index: 1000;
        box-shadow: 0 0 12px var(--sparkle-color, #FFD700);
    }

    .sparkle::before {
        content: '✨';
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 14px;
        animation: sparkleRotate 0.9s ease-out;
    }

    .sparkle::after {
        content: '';
        position: absolute;
        top: -2px;
        left: -2px;
        right: -2px;
        bottom: -2px;
        background: radial-gradient(circle, transparent 40%, var(--sparkle-color, #FFD700) 70%, transparent 100%);
        border-radius: 50%;
        opacity: 0.6;
        animation: sparkleGlow 0.9s ease-out;
    }

    @keyframes magicalSparkle {
        0% { 
            transform: scale(0.3) rotate(0deg); 
            opacity: 0; 
        }
        20% { 
            opacity: 1; 
            transform: scale(1.2) rotate(90deg); 
        }
        80% { 
            opacity: 0.8; 
            transform: scale(0.8) rotate(270deg) translateY(-20px); 
        }
        100% { 
            transform: scale(0) rotate(360deg) translateY(-40px); 
            opacity: 0; 
        }
    }

    @keyframes sparkleRotate {
        0% { transform: translate(-50%, -50%) rotate(0deg) scale(0.5); }
        50% { transform: translate(-50%, -50%) rotate(180deg) scale(1.2); }
        100% { transform: translate(-50%, -50%) rotate(360deg) scale(0.3); }
    }

    @keyframes sparkleGlow {
        0% { opacity: 0; transform: scale(0.5); }
        50% { opacity: 0.8; transform: scale(1.5); }
        100% { opacity: 0; transform: scale(2); }
    }

    /* Exit Modal Styling */
    .exit-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 2000;
        backdrop-filter: blur(5px);
    }

    .exit-modal-content {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 2rem;
        max-width: 400px;
        max-height: 85vh;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 40px rgba(255, 193, 7, 0.3);
        border: 3px solid rgba(255, 193, 7, 0.5);
        animation: modalBounceIn 0.4s ease-out;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .exit-modal-header h3 {
        color: #6d4c00;
        margin: 0 0 1rem 0;
        font-size: 1.5rem;
    }

    .exit-modal-body p {
        color: #6d4c00;
        margin: 0.5rem 0;
        font-size: 1.1rem;
    }

    .exit-stats {
        background: rgba(255, 215, 0, 0.1);
        border-radius: 12px;
        padding: 1rem;
        margin: 1rem 0;
        color: #B8860B;
        font-weight: 600;
    }

    .exit-modal-buttons {
        display: flex;
        gap: 1rem;
        margin-top: 1.5rem;
    }

    .exit-modal-buttons .action-btn {
        flex: 1;
        min-height: 50px;
    }

    @keyframes modalBounceIn {
        0% { transform: scale(0.3) rotate(-10deg); opacity: 0; }
        50% { transform: scale(1.05) rotate(2deg); opacity: 1; }
        100% { transform: scale(1) rotate(0deg); opacity: 1; }
    }

    /* Voice Intro Modal - iOS Friendly */
    .voice-intro-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.75);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 3000;
        backdrop-filter: blur(8px);
    }

    .voice-intro-content {
        background: linear-gradient(135deg, #FFFFFF 0%, #FFF9E6 100%);
        border-radius: 24px;
        padding: 2.5rem 2rem;
        max-width: 450px;
        max-height: 85vh;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 50px rgba(255, 140, 0, 0.4);
        border: 4px solid #FFD700;
        animation: modalBounceIn 0.5s ease-out;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
    }

    .voice-intro-icon {
        font-size: 4rem;
        margin-bottom: 1rem;
        animation: bounce 1s infinite;
    }

    @keyframes bounce {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-10px); }
    }

    .voice-intro-content h2 {
        color: #FF6B00;
        margin: 0 0 1rem 0;
        font-size: 1.8rem;
        text-shadow: 2px 2px 4px rgba(255, 107, 0, 0.2);
    }

    .voice-intro-content p {
        color: #6d4c00;
        margin: 0.75rem 0;
        font-size: 1.1rem;
        line-height: 1.5;
    }

    .voice-intro-buttons {
        display: flex;
        flex-direction: column;
        gap: 1rem;
        margin-top: 1.5rem;
    }

    .voice-intro-buttons .action-btn {
        width: 100%;
        min-height: 55px;
        font-size: 1.1rem;
    }

    .action-btn.primary {
        background: linear-gradient(90deg, #FFB300 0%, #FFD54F 100%);
        color: #2b2100;
        box-shadow: 0 4px 15px rgba(255, 193, 7, 0.3);
    }

    .action-btn.primary:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 6px 20px rgba(255, 193, 7, 0.5);
        background: linear-gradient(90deg, #FFA000 0%, #FFC107 100%);
    }

    .action-btn.primary:active {
        transform: translateY(0px);
        box-shadow: 0 2px 10px rgba(255, 193, 7, 0.3);
        transition: all 0.1s ease;
    }

    .action-btn.primary:disabled {
        background: #ccc;
        cursor: not-allowed;
        opacity: 0.6;
        transform: none;
        box-shadow: none;
    }

    .action-btn.secondary {
        background: rgba(255, 215, 0, 0.1);
        color: #B8860B;
        border: 2px solid rgba(255, 213, 79, 0.6);
        position: relative;
        overflow: hidden;
    }

    .action-btn.secondary::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
        transition: left 0.5s ease;
    }

    .action-btn.secondary:hover {
        background: rgba(255, 215, 0, 0.2);
        border-color: #FFD700;
        transform: translateY(-2px);
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.3);
    }

    .action-btn.secondary:hover::before {
        left: 100%;
    }

    .action-btn.secondary:active {
        transform: translateY(0px);
        box-shadow: 0 2px 8px rgba(255, 215, 0, 0.2);
        transition: all 0.1s ease;
    }

    /* Button Sound and Visual Effects */
    .action-btn.buzz-effect {
        animation: buttonBuzz 0.3s ease;
    }

    .action-btn.ripple-effect {
        animation: buttonRipple 0.4s ease;
    }

    @keyframes buttonBuzz {
        0%, 100% { transform: translateY(-2px) rotate(0deg); }
        25% { transform: translateY(-2px) rotate(1deg); }
        50% { transform: translateY(-2px) rotate(0deg); }
        75% { transform: translateY(-2px) rotate(-1deg); }
    }

    @keyframes buttonRipple {
        0% { transform: translateY(-2px) scale(1); box-shadow: 0 6px 20px rgba(255, 193, 7, 0.5); }
        50% { transform: translateY(-2px) scale(1.05); box-shadow: 0 8px 25px rgba(255, 193, 7, 0.7); }
        100% { transform: translateY(-2px) scale(1); box-shadow: 0 6px 20px rgba(255, 193, 7, 0.5); }
    }

    /* Slide In Up Animation for Honey Pot */
    @keyframes slideInUp {
        from {
            opacity: 0;
            transform: translateY(30px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* Input Field - Match Voice Visualizer Width */
    .bee-input {
        width: 100%;
        margin: 1.5rem 0;
        display: flex;
        justify-content: center;
    }

    .bee-input input[type="text"] {
        width: 100%;
        max-width: none;
        border: 3px solid #FFC107;
        border-radius: 20px;
        box-shadow: 0 0 0 rgba(255, 193, 7, 0.0);
        transition: box-shadow 0.3s ease, transform 0.2s ease;
        padding: 1.2rem 2rem;
        font-size: 1.25rem;
        text-align: center;
        background-color: rgba(255, 255, 255, 0.93);
        color: #332300;
        box-sizing: border-box;
    }
    
    /* Explosion animation for correct answers */
    @keyframes explode {
        0% {
            transform: translate(0, 0) scale(1) rotate(0deg);
            opacity: 1;
        }
        50% {
            opacity: 1;
        }
        100% {
            transform: translate(var(--tx), var(--ty)) scale(0.3) rotate(720deg);
            opacity: 0;
        }
    }
    
    @keyframes pulse {
        0%, 100% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.1);
        }
    }
    
    @keyframes fadeIn {
        from {
            opacity: 0;
        }
        to {
            opacity: 1;
        }
    }
    
    @keyframes modalSlideIn {
        from {
            transform: translateY(-30px) scale(0.95);
            opacity: 0;
        }
        to {
            transform: translateY(0) scale(1);
            opacity: 1;
        }
    }
    
    /* Mobile-specific touch optimizations */
    @media (hover: none) and (pointer: coarse) {
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
        }
        
        button, .quiz-button, .action-btn {
            -webkit-tap-highlight-color: rgba(255, 182, 193, 0.3);
            touch-action: manipulation;
            min-height: 44px;
            -webkit-user-select: none;
            user-select: none;
        }
        
        input {
            font-size: 16px !important; /* Prevent iOS zoom */
        }
        
        html {
            -webkit-overflow-scrolling: touch;
        }
    }
    
    /* 🍯 HONEY POINTS POPUP ANIMATION */
    .points-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0.5);
        background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
        color: #5A2C15;
        padding: 1.5rem 2rem;
        border-radius: 20px;
        box-shadow: 0 8px 30px rgba(255, 193, 7, 0.5),
                    inset 0 2px 10px rgba(255, 255, 255, 0.3);
        border: 3px solid rgba(255, 215, 0, 0.8);
        z-index: 9999;
        opacity: 0;
        animation: pointsPopup 2.5s ease-out forwards;
        pointer-events: none;
        min-width: 250px;
        text-align: center;
    }
    
    .points-total {
        font-size: 2.5rem;
        font-weight: 900;
        margin-bottom: 0.5rem;
        text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
    }
    
    .points-total::before {
        content: '🍯';
        font-size: 2rem;
    }
    
    .points-breakdown {
        font-size: 0.9rem;
        font-weight: 600;
        opacity: 0.9;
        margin-top: 0.8rem;
        padding-top: 0.8rem;
        border-top: 2px solid rgba(90, 44, 21, 0.2);
        line-height: 1.6;
    }
    
    .points-breakdown-item {
        display: flex;
        justify-content: space-between;
        padding: 0.2rem 0;
    }
    
    @keyframes pointsPopup {
        0% {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.5);
        }
        15% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }
        20% {
            transform: translate(-50%, -50%) scale(1);
        }
        85% {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
        100% {
            opacity: 0;
            transform: translate(-50%, -60%) scale(0.9);
        }
    }
    
    /* Session Points Tracker */
    .session-stats {
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 1.5rem;
        background: linear-gradient(135deg, rgba(255, 193, 7, 0.95), rgba(255, 152, 0, 0.95));
        padding: 0.8rem 1.5rem;
        border-radius: 50px;
        box-shadow: 0 4px 15px rgba(255, 152, 0, 0.3);
        z-index: 100;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }
    
    .session-stat {
        display: flex;
        align-items: center;
        gap: 0.4rem;
        font-weight: 700;
        color: #5A2C15;
        font-size: 1rem;
    }
    
    .session-stat-value {
        font-size: 1.2rem;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
    }
    
    /* 🏆 BADGE UNLOCK MODAL */
    .badge-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease-out;
    }
    
    .badge-modal-content {
        background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
        border-radius: 30px;
        padding: 3rem;
        max-width: 500px;
        text-align: center;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5),
                    inset 0 2px 20px rgba(255, 255, 255, 0.3);
        border: 4px solid rgba(255, 215, 0, 0.8);
        animation: badgePopIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        position: relative;
    }
    
    .badge-icon {
        font-size: 6rem;
        margin-bottom: 1rem;
        animation: badgeSpin 1s ease-out;
        display: inline-block;
    }
    
    .badge-modal h2 {
        color: #5A2C15;
        font-size: 2.5rem;
        margin: 0 0 1rem 0;
        text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.5);
    }
    
    .badge-modal h3 {
        color: #5A2C15;
        font-size: 1.8rem;
        margin: 0 0 1rem 0;
    }
    
    .badge-modal p {
        color: #5A2C15;
        font-size: 1.2rem;
        margin: 0.5rem 0;
        font-weight: 600;
    }
    
    .badge-points {
        font-size: 2rem !important;
        font-weight: 900 !important;
        margin-top: 1.5rem !important;
        text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.6);
    }
    
    .badge-continue-btn {
        background: linear-gradient(135deg, #66BB6A, #4CAF50);
        color: white;
        border: none;
        padding: 1rem 2.5rem;
        font-size: 1.3rem;
        font-weight: 700;
        border-radius: 50px;
        cursor: pointer;
        margin-top: 2rem;
        box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
        transition: all 0.3s ease;
    }
    
    .badge-continue-btn:hover {
        transform: scale(1.05);
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
    }
    
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    
    @keyframes badgePopIn {
        0% {
            transform: scale(0.3) rotate(-180deg);
            opacity: 0;
        }
        50% {
            transform: scale(1.1) rotate(10deg);
        }
        100% {
            transform: scale(1) rotate(0deg);
            opacity: 1;
        }
    }
    
    @keyframes badgeSpin {
        0% {
            transform: rotate(0deg) scale(0.5);
            opacity: 0;
        }
        50% {
            transform: rotate(180deg) scale(1.2);
        }
        100% {
            transform: rotate(360deg) scale(1);
            opacity: 1;
        }
    }
    
    /* Confetti particles for badge unlock */
    .confetti {
        position: fixed;
        width: 10px;
        height: 10px;
        background: #FFD700;
        animation: confettiFall 3s ease-out forwards;
        z-index: 9999;
    }
    
    @keyframes confettiFall {
        0% {
            transform: translateY(0) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(720deg);
            opacity: 0;
        }
    }
    
    /* 🎯 LEVEL UP MODAL */
    .level-up-modal {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, rgba(102, 187, 106, 0.95), rgba(76, 175, 80, 0.95));
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10001;
        animation: fadeIn 0.3s ease-out;
    }
    
    .level-up-content {
        background: linear-gradient(135deg, #FFF9C4 0%, #FFF59D 100%);
        border-radius: 40px;
        padding: 3rem 4rem;
        max-width: 600px;
        text-align: center;
        box-shadow: 0 25px 70px rgba(0, 0, 0, 0.6),
                    inset 0 2px 25px rgba(255, 255, 255, 0.4);
        border: 5px solid #FFD700;
        animation: levelUpBounce 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        position: relative;
    }
    
    .level-up-title {
        font-size: 3rem;
        color: #388E3C;
        margin: 0 0 1rem 0;
        text-shadow: 3px 3px 6px rgba(255, 255, 255, 0.7);
        font-weight: 900;
    }
    
    .level-up-icon-large {
        font-size: 8rem;
        margin: 1rem 0;
        animation: levelUpPulse 1s infinite ease-in-out;
        display: inline-block;
    }
    
    .level-up-tier {
        font-size: 2.5rem;
        color: #1B5E20;
        font-weight: 800;
        margin: 1rem 0;
        text-shadow: 2px 2px 4px rgba(255, 255, 255, 0.6);
    }
    
    .level-up-message {
        font-size: 1.3rem;
        color: #2E7D32;
        margin: 1rem 0 2rem 0;
        font-weight: 600;
    }
    
    .level-progress-display {
        background: rgba(255, 255, 255, 0.5);
        border-radius: 15px;
        padding: 1rem;
        margin: 1.5rem 0;
    }
    
    .level-progress-display p {
        margin: 0.5rem 0;
        font-size: 1.1rem;
        color: #1B5E20;
        font-weight: 600;
    }
    
    .level-continue-btn {
        background: linear-gradient(135deg, #66BB6A, #4CAF50);
        color: white;
        border: none;
        padding: 1.2rem 3rem;
        font-size: 1.4rem;
        font-weight: 800;
        border-radius: 50px;
        cursor: pointer;
        margin-top: 1.5rem;
        box-shadow: 0 6px 20px rgba(76, 175, 80, 0.5);
        transition: all 0.3s ease;
    }
    
    .level-continue-btn:hover {
        transform: scale(1.08);
        box-shadow: 0 8px 25px rgba(76, 175, 80, 0.7);
    }
    
    @keyframes levelUpBounce {
        0% {
            transform: scale(0.2) translateY(-100vh);
            opacity: 0;
        }
        60% {
            transform: scale(1.1) translateY(0);
        }
        80% {
            transform: scale(0.95);
        }
        100% {
            transform: scale(1);
            opacity: 1;
        }
    }
    
    @keyframes levelUpPulse {
        0%, 100% {
            transform: scale(1);
        }
        50% {
            transform: scale(1.15);
        }
    }
    
    @media (max-width: 768px) {
        .session-stats {
            top: 10px;
            gap: 1rem;
            padding: 0.6rem 1rem;
        }
        
        .session-stat {
            font-size: 0.85rem;
        }
        
        .session-stat-value {
            font-size: 1rem;
        }
        
        .points-popup {
            min-width: 200px;
            padding: 1.2rem 1.5rem;
        }
        
        .points-total {
            font-size: 2rem;
        }
        
        .points-breakdown {
            font-size: 0.8rem;
        }
        
        .badge-modal-content {
            max-width: 90%;
            padding: 2rem 1.5rem;
        }
        
        .badge-icon {
            font-size: 4rem;
        }
        
        .badge-modal h2 {
            font-size: 2rem;
        }
        
        .badge-modal h3 {
            font-size: 1.5rem;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="floating-bee" aria-hidden="true"></div>
<div class="floating-bee" aria-hidden="true"></div>
<div class="floating-bee" aria-hidden="true"></div>

<div class="quiz-container quiz-shell">
    <!-- Quiz Header -->
    <div class="quiz-header">
        <!-- Back button and question count -->
        <div class="progress-info">
            <div class="progress-text">
                <a href="#" onclick="confirmBackToMenu(event)" class="back-button">
                    <span class="arrow">🔙</span>
                    <span>Back to Menu</span>
                </a>
                <span id="progressText">Question 1 of 10</span>
            </div>
        </div>

        <div class="score-display">
            <div class="score-item">
                <span class="score-number correct" id="correctCount">0</span>
                <span class="score-label">Correct</span>
            </div>
            
            <div class="score-item">
                <span class="score-number incorrect" id="incorrectCount">0</span>
                <span class="score-label">Incorrect</span>
            </div>
            
            <div class="score-item">
                <span class="score-number streak" id="streakCount">0</span>
                <span class="score-label">Streak</span>
            </div>
            
            <div class="score-item">
                <span class="score-number points" id="sessionPoints" style="color: #FFD700;">0</span>
                <span class="score-label">Points</span>
            </div>
        </div>
    </div>

    <!-- Quiz Card -->
    <div class="quiz-card" id="quizCard">
        <!-- Logo at top center -->
        <div class="quiz-logo">
            <!-- Text-only logo - MOVED TO TOP -->
            <img src="{{ url_for('static', filename='BeeSmartTitle.png') }}" alt="BeeSmart Spelling Bee">
            
            <!-- 3D Mascot (renamed to mascotBee3D) - MOVED BELOW TITLE -->
            <div id="mascotBee3D" class="mascot-3d-container"></div>
            
            <!-- Kid-Safe Content Badge -->
            <div class="kid-safe-badge-quiz" title="All words are automatically filtered for age-appropriate content">
                <span>Kid-Safe Words</span>
            </div>
        </div>

        <!-- Version Info -->
        <div class="version-info">
            <small>JS v3-cache-1768522562258</small>
        </div>

        <div class="definition-display" id="definitionDisplay">
            Loading your first word...
        </div>
        
        <!-- Voice Toggle Button - Centered -->
        <div class="voice-toggle-container" style="display:flex; justify-content:center; align-items:center; margin: 1rem 0; width: 100%;">
            <button type="button" class="action-btn secondary" id="voiceToggleBtn" title="Toggle announcer voice">
                <span class="bee-icon" aria-hidden="true" id="voiceToggleIcon">🔊</span>
                <span id="voiceToggleText">Mute Buzzy</span>
            </button>
        </div>

        <!-- ⏱️ Countdown Timer - Honey Jar -->
        <div class="countdown-container hidden" id="countdownContainer">
            <div class="honey-jar-timer" id="honeyJarTimer">
                <div class="jar-outline">
                    <div class="honey-fill" id="honeyFill"></div>
                    <div class="honey-bubbles">
                        <span class="bubble"></span>
                        <span class="bubble"></span>
                        <span class="bubble"></span>
                    </div>
                </div>
                <div class="timer-number" id="timerNumber">60</div>
                <div class="timer-label">seconds</div>
            </div>
        </div>

                <!-- Voice Visualizer (Upgraded dotted rainbow ribbon) -->
                <div class="voice-visualizer" id="voiceVisualizer">
                        <div class="voice-card speaking-mode">
                            <div class="voice-header">
                                <span class="voice-bee">🐝</span>
                                <span class="voice-text" id="voiceStatus">Ready</span>
                            </div>

                            <div class="dotwave-wrapper">
                                <canvas id="dotWaveCanvas" width="500" height="160"></canvas>
                            </div>
                        </div>
                </div>

                <!-- Dotted ribbon CSS (BeeSmart glowing dots) -->
                <style>
                    .voice-card.speaking-mode {
                        background: radial-gradient(circle at 30% 30%, #ffa726 0%, #ef6c00 60%, #c14900 100%);
                        border-radius: 28px;
                        padding: 24px 16px 32px;
                        border: 2px solid rgba(255,255,255,0.25);
                        box-shadow:
                            0 24px 40px rgba(255,140,0,0.35),
                            0 0 60px rgba(255,214,79,0.35) inset;
                        max-width: 520px;
                        margin: 0 auto 24px auto;
                        color: #fff;
                        text-align: center;
                        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", "Roboto", sans-serif;
                                    overflow: hidden; /* keep dots within card corners */
                    }

                    .voice-header {
                        font-size: 1.25rem;
                        font-weight: 600;
                        color: #fff8e1;
                        text-shadow:
                            0 0 6px rgba(255,255,255,0.8),
                            0 0 12px rgba(255,214,64,0.8);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        letter-spacing: 0.02em;
                        margin-bottom: 20px;
                    }

                    .voice-bee {
                        margin-right: 8px;
                        display: inline-block;
                        filter:
                            drop-shadow(0 0 4px #fff)
                            drop-shadow(0 0 8px #ffd54f);
                    }

                                .dotwave-wrapper {
                                    display: flex;
                                    justify-content: center;
                                    align-items: center;
                                    padding: 8px 16px; /* small buffer from edges */
                                }

                                .dotwave-wrapper canvas {
                                    width: 100%;
                                    height: 180px; /* fill more vertical space */
                                    filter:
                                        drop-shadow(0 0 4px rgba(255,255,255,0.4))
                                        drop-shadow(0 0 12px rgba(255,200,0,0.4));
                                }
                </style>

                <!-- Dotted ribbon config (shared across pages) -->
                <script src="/static/js/voice-visualizer-config.js"></script>
                <!-- Dotted ribbon JS with speech-state awareness -->
                <script>
                (function(){
                                const canvas = document.getElementById('dotWaveCanvas');
                    if (!canvas) return;
                    const ctx = canvas.getContext('2d');

                                let W = canvas.width;
                                let H = canvas.height;
                                let DPR = window.devicePixelRatio || 1;

                    // Resize handler to keep crisp drawing on DPR changes
                    function resizeCanvas(){
                                    DPR = window.devicePixelRatio || 1;
                                    const cssWidth = canvas.clientWidth || 500;
                                    const cssHeight = canvas.clientHeight || 160;
                                    canvas.width = Math.round(cssWidth * DPR);
                                    canvas.height = Math.round(cssHeight * DPR);
                        canvas.style.width = cssWidth + 'px';
                        canvas.style.height = cssHeight + 'px';
                                    W = canvas.width; H = canvas.height;
                    }
                    resizeCanvas();
                    window.addEventListener('resize', resizeCanvas);

                    // CONFIG (from shared file with safe fallbacks)
                                const VZ = window.BeeSmartVoiceVizCfg || {};
                                const pick = (v, d) => (v !== undefined && v !== null) ? v : d;
                                const MAX_WAVES = pick(VZ.MAX_WAVES, 6); // maximum; collapses to one on pauses
                                let wavePack = 1;     // 1 => draw all waves, 0 => only one
                                let wavePackTarget = 1;
                                const DOTS_PER_WAVE = pick(VZ.DOTS_PER_WAVE, 56); // more points for a defined curve
                    const DOT_RADIUS = pick(VZ.DOT_RADIUS, 3);
                    const WAVE_SPACING = pick(VZ.WAVE_SPACING, 20);  // spacing for definition
                                const HORIZONTAL_PAD_CSS = pick(VZ.HORIZONTAL_PAD_CSS, 12); // reduced buffer for longer lines
                                const waveColors = (VZ.waveColors && VZ.waveColors.length) ? VZ.waveColors : ['rgba(255, 190, 52, 0.80)'];

                                // Visualizer state (driven by announcer): speaking | pausing | idle
                                let mode = 'idle';
                                const ET = VZ.energyTargets || {};
                                let energyTarget = pick(ET.idle, 0.04);
                                let energy = energyTarget;
                                // Transitional boosts to make pauses/speeches feel more pronounced
                                let dipBoost = 0;   // 0..1 extra reduction when pausing begins
                                let surgeBoost = 0; // 0..1 extra lift when speaking begins

                    function setMode(next){
                                    if (mode !== next) {
                                        if (next === 'pausing') dipBoost = 1;      // immediate dip
                                        if (next === 'speaking') surgeBoost = 1;   // immediate lift
                                    }
                                    mode = next;
                        // Expand waves while speaking; collapse to one when paused/idle
                        wavePackTarget = (mode === 'speaking') ? 1 : 0;
                                    if (mode === 'speaking') energyTarget = pick(ET.speaking, 1.0);
                                    else if (mode === 'pausing') energyTarget = pick(ET.pausing, 0.06);
                                    else energyTarget = pick(ET.idle, 0.04);
                    }
                    // Expose to page scripts
                    window.voiceVizSetMode = setMode;

                    // Observe class changes on #voiceVisualizer to auto-sync mode
                    const host = document.getElementById('voiceVisualizer');
                    if (host && 'MutationObserver' in window){
                        const mo = new MutationObserver(() => {
                            const c = host.classList;
                            if (c.contains('speaking')) setMode('speaking');
                            else if (c.contains('pausing')) setMode('pausing');
                            else setMode('idle');
                        });
                        mo.observe(host, { attributes: true, attributeFilter: ['class'] });
                    }

                    // Lightweight helper to trigger quick visual reactions from UI events
                    window.BeeVoiceViz = (function(){
                        function hostEl(){ return document.getElementById('voiceVisualizer'); }
                        function speak(ms=600){ const h=hostEl(); if(!h) return; h.classList.add('speaking'); setTimeout(()=>h.classList.remove('speaking'), ms); }
                        function pulse(ms=220){ const h=hostEl(); if(!h) return; h.classList.add('pausing','word-pulse'); setTimeout(()=>h.classList.remove('pausing','word-pulse'), ms); }
                        function react(kind){
                            switch(kind){
                                case 'button': return pulse(200);
                                case 'submit': return speak(480);
                                case 'hint': return pulse(260);
                                case 'skip': return pulse(300);
                                case 'feedback-correct': return speak(700);
                                case 'feedback-incorrect': return pulse(520);
                                default: return pulse(180);
                            }
                        }
                        return { speak, pulse, react };
                    })();

                                function getEnergy(t){
                        // base animated energy 0..1
                        const fake = 0.5 + 0.5*Math.sin(t*0.002) + 0.25*Math.sin(t*0.005 + 2);
                        return Math.max(0, Math.min(1, fake));
                    }

                    function drawFrame(t){
                                    // Ease energy toward target faster so pauses are visible
                                    const base = getEnergy(t);
                                    const E = VZ.easing || {};
                                    const ENERGY_EASE = pick(E.energy, 0.18);
                                    const WAVEPACK_EASE = pick(E.wavePack, 0.22);
                                    const DIP_DECAY = pick(E.dipDecay, 0.15);
                                    const SURGE_DECAY = pick(E.surgeDecay, 0.10);
                                    const B = VZ.boostScales || {};
                                    const DIP_SCALE = pick(B.dip, 0.65);
                                    const SURGE_SCALE = pick(B.surge, 0.15);
                                    const SH = VZ.waveShape || {};
                                    energy += (energyTarget - energy) * ENERGY_EASE;
                                    // Ease the number of visible waves toward target (1 or many)
                                    wavePack += (wavePackTarget - wavePack) * WAVEPACK_EASE;
                                    // decay boosts
                                    dipBoost += (0 - dipBoost) * DIP_DECAY;
                                    surgeBoost += (0 - surgeBoost) * SURGE_DECAY;
                                    // Apply boosts: stronger downward dip when pausing, small lift when speaking resumes
                                    const motionScale = (1 - DIP_SCALE * dipBoost) * (1 + SURGE_SCALE * surgeBoost);
                                    const drive = base * energy * motionScale;

                        ctx.clearRect(0,0,W,H);

                        // Precompute horizontal padding and optional L-R gradient overlay
                        const pad = HORIZONTAL_PAD_CSS * DPR;
                        const GR = VZ.gradientLR || {};
                        let grad = null;
                        if (GR.enabled) {
                            grad = ctx.createLinearGradient(pad, 0, W - pad, 0);
                            const stops = GR.stops || [];
                            for (let s = 0; s < stops.length; s++) {
                                const st = stops[s] || {};
                                const off = (typeof st.offset === 'number') ? st.offset : (s/(Math.max(1,stops.length-1)));
                                const col = st.color || '#ffffff';
                                grad.addColorStop(off, col);
                            }
                        }

                        // End-fade configuration (transparent at both ends)
                        const EF = VZ.endFade || {};
                        const EF_ENABLED = (EF.enabled !== undefined) ? !!EF.enabled : true;
                        const fadeFrac = (typeof EF.fraction === 'number') ? Math.max(0, Math.min(0.5, EF.fraction)) : 0.16;
                        const drawableWidth = Math.max(1, (W - 2*pad));
                        const fadeWidth = Math.max(8 * DPR, fadeFrac * drawableWidth);
                        function edgeFadeAlpha(x){
                            if (!EF_ENABLED) return 1;
                            // distance to nearest drawable edge
                            const leftDist = x - pad;
                            const rightDist = (pad + drawableWidth) - x;
                            const d = Math.max(0, Math.min(leftDist, rightDist));
                            const u = Math.max(0, Math.min(1, d / fadeWidth)); // 0 at edge -> 1 away
                            // cosine smoothstep for a soft fade in/out
                            return 0.5 - 0.5 * Math.cos(Math.PI * u);
                        }

                        const wavesToDraw = Math.max(1, Math.round(1 + (MAX_WAVES-1) * wavePack));
                        // Clip to safe drawable area to guarantee nothing bleeds past card border
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(pad, 0, W - 2*pad, H);
                        ctx.clip();
                        for (let w = 0; w < wavesToDraw; w++) {
                            const color = waveColors[w % waveColors.length];
                            const yOffset = -w * WAVE_SPACING;

                            for (let i = 0; i < DOTS_PER_WAVE; i++) {
                                const progress = i / (DOTS_PER_WAVE - 1);
                                const x = progress * (W - 2*pad) + pad; // keep inside edges

                                const freq = pick(SH.baseFreq, 2) + w * pick(SH.freqStep, 0.4);
                                const phase = t*0.004 + w*0.6;
                                let amp = (pick(SH.ampBase, 28) + w*pick(SH.ampStep, 8)) * drive; // INCREASED: More pronounced peaks (was 12 and 4)

                                // Edge tip pinch: collapse amplitude and spacing near ends so waves meet
                                const TP = VZ.tipPinch || {};
                                let pinch = 1;
                                if (TP.enabled) {
                                    const p = (typeof TP.power === 'number') ? TP.power : 1.25;
                                    pinch = Math.pow(Math.sin(Math.PI * progress), Math.max(0.8, Math.min(2.0, p)));
                                    amp *= pinch;
                                }

                                // Thickness bulge across X to mimic a wavy sheet
                                const TB = VZ.thicknessBulge || {};
                                if (TB.enabled) {
                                    const bulgeMag = (typeof TB.magnitude === 'number') ? TB.magnitude : 0.18;
                                    const bulgeSpeed = (typeof TB.speed === 'number') ? TB.speed : 0.002;
                                    const bulgeCycles = (typeof TB.cycles === 'number') ? TB.cycles : 1.2;
                                    const bulge = 1 + bulgeMag * Math.sin(progress * Math.PI * 2 * bulgeCycles + t * bulgeSpeed * 1000);
                                    amp *= bulge;
                                }

                                const mainWaveY = Math.sin(progress * freq * Math.PI + phase) * amp;
                                const ripple = Math.sin(progress * pick(SH.rippleFreq, 12) + t*0.01 + w) * (pick(SH.rippleBase, 3) + w) * (0.5 + 0.5*drive);
                                // Collapse vertical spacing yOffset near tips using the same pinch scale
                                const y = (H/2 + 20*DPR) + (yOffset * pinch) + mainWaveY + ripple;

                                const edgeA = edgeFadeAlpha(x);

                                ctx.beginPath();
                                ctx.fillStyle = color;
                                ctx.shadowColor = color;
                                ctx.shadowBlur = 3 * edgeA; // REDUCED: Remove halo effect (was 12)
                                const prevAlpha = ctx.globalAlpha;
                                ctx.globalAlpha = edgeA;
                                ctx.arc(x, y, DOT_RADIUS, 0, Math.PI*2);
                                ctx.fill();
                                ctx.closePath();

                                // Optional gradient overlay for L->R color sweep
                                if (grad) {
                                    const alpha = (typeof GR.alpha === 'number') ? GR.alpha : 0.45;
                                    const savedAlpha = ctx.globalAlpha;
                                    const prevShadow = ctx.shadowBlur;
                                    ctx.globalAlpha = edgeA * alpha; // apply end fade to overlay too
                                    ctx.shadowBlur = 0; // overlay without glow
                                    ctx.beginPath();
                                    ctx.fillStyle = grad;
                                    ctx.arc(x, y, DOT_RADIUS, 0, Math.PI*2);
                                    ctx.fill();
                                    ctx.closePath();
                                    ctx.globalAlpha = savedAlpha;
                                    ctx.shadowBlur = prevShadow;
                                }
                                // restore for next dot if no overlay
                                ctx.globalAlpha = prevAlpha;
                            }
                        }
                        ctx.restore();

                        // Soft central glow overlay (lighter blend), scaled by energy
                        const CG = VZ.centerGlow || {};
                        if (CG.enabled) {
                            const baseAlpha = (typeof CG.alpha === 'number') ? CG.alpha : 0.15; // REDUCED: Less glow/halo (was 0.5)
                            const span = (typeof CG.verticalSpan === 'number') ? Math.max(0.1, Math.min(1, CG.verticalSpan)) : 0.55;
                            const energyScale = (typeof CG.energyScale === 'number') ? CG.energyScale : 0.9;
                            const horizFrac = (typeof CG.horizontalFraction === 'number') ? Math.max(0, Math.min(0.5, CG.horizontalFraction)) : 0.15;
                            const glowAlpha = baseAlpha * Math.max(0, Math.min(1, energy * energyScale));
                            const drawableWidth2 = Math.max(1, (W - 2*pad));
                            const feather = Math.max(8 * DPR, horizFrac * drawableWidth2);
                            if (glowAlpha > 0.01) {
                                // Draw vertical glow into an offscreen canvas
                                const off = document.createElement('canvas');
                                off.width = W; off.height = H;
                                const ox = off.getContext('2d');
                                const top = (H*(1-span))/2;
                                const bottom = H - top;
                                const gradY = ox.createLinearGradient(0, top, 0, bottom);
                                gradY.addColorStop(0.0, 'rgba(255,255,255,0)');
                                gradY.addColorStop(0.5, 'rgba(255,255,255,1)');
                                gradY.addColorStop(1.0, 'rgba(255,255,255,0)');
                                ox.fillStyle = gradY;
                                ox.fillRect(pad, top, W - 2*pad, bottom - top);

                                // Mask with horizontal taper using destination-in
                                const gradX = ox.createLinearGradient(pad, 0, W - pad, 0);
                                const leftStop = pad + feather;
                                const rightStop = (W - pad) - feather;
                                const lOff = Math.max(0, Math.min(1, (leftStop - pad) / drawableWidth2));
                                const rOff = Math.max(0, Math.min(1, (rightStop - pad) / drawableWidth2));
                                gradX.addColorStop(0, 'rgba(0,0,0,0)');
                                gradX.addColorStop(lOff, 'rgba(0,0,0,1)');
                                gradX.addColorStop(rOff, 'rgba(0,0,0,1)');
                                gradX.addColorStop(1, 'rgba(0,0,0,0)');
                                ox.globalCompositeOperation = 'destination-in';
                                ox.fillStyle = gradX;
                                ox.fillRect(pad, 0, W - 2*pad, H);

                                // Blend back onto main
                                const prevComp = ctx.globalCompositeOperation;
                                const prevAlpha2 = ctx.globalAlpha;
                                ctx.globalCompositeOperation = 'lighter';
                                ctx.globalAlpha = glowAlpha;
                                ctx.drawImage(off, 0, 0);
                                ctx.globalCompositeOperation = prevComp;
                                ctx.globalAlpha = prevAlpha2;
                            }
                        }
                        requestAnimationFrame(drawFrame);
                    }

                    // Kick off
                    setMode('idle');
                    requestAnimationFrame(drawFrame);
                })();
                </script>

        <div class="bee-input" id="beeInputWrapper">
            <input type="text"
                   id="spellingInput"
                   placeholder="Type your spelling here..."
                   autocomplete="off"
                   autocorrect="off"
                   autocapitalize="off"
                   spellcheck="false">
        </div>

        <!-- Letter Hint Display -->
        <div class="letter-hint hidden" id="letterHint" aria-live="polite">
            <span class="hint-label">💡 Hint:</span>
            <span class="hint-letters" id="hintLetters"></span>
        </div>

        <div class="phonetic-reveal hidden" id="phoneticHint" aria-live="polite"></div>

        <div class="feedback-area" id="feedbackArea" role="status" aria-live="polite"></div>

        <div class="quiz-buttons">
            <!-- Voice Control Buttons -->
            <button type="button" class="action-btn secondary" id="speakButton">
                <span class="bee-icon" aria-hidden="true">🔊</span>
                Pronounce Word
            </button>
            
            <button type="button" class="action-btn secondary" id="repeatButton">
                <span class="bee-icon" aria-hidden="true">🔁</span>
                Repeat
            </button>
            
            <!-- Quiz Action Buttons -->
            <button type="button" class="action-btn primary" id="submitButton">
                Submit Answer
            </button>
            <button type="button" class="action-btn secondary" id="getHintButton">
                Honey Hint
            </button>
            <button type="button" class="action-btn secondary" id="skipButton">
                Skip Word
            </button>
            <button type="button" class="action-btn exit" id="exitQuizButton">
                <span class="bee-icon" aria-hidden="true">🚪</span>
                Exit Quiz
            </button>
        </div>
    </div>

    <!-- Quiz Complete Screen -->
    <div class="quiz-complete" id="quizComplete" style="display: none;">
        <h2>📊 Your Report Card!</h2>
        <p>Great job practicing your spelling!</p>

        <div class="completion-stats" id="completionStats"></div>

        <div class="quiz-buttons">
            <button type="button" class="quiz-button btn-success" id="restartButton">
                Practice Again
            </button>
            <a href="/" class="quiz-button btn-secondary">
                Back to Menu
            </a>
        </div>
    </div>

    <!-- Exit Quiz Confirmation Modal -->
    <div class="exit-modal" id="exitModal" style="display: none;">
        <div class="exit-modal-content">
            <div class="exit-modal-header">
                <h3>🐝 Hold on, busy bee!</h3>
            </div>
            <div class="exit-modal-body">
                <p>Are you sure you want to leave your spelling practice?</p>
                <p>🌟 You're doing great and every word makes you smarter!</p>
                <div class="exit-stats" id="exitStats"></div>
            </div>
            <div class="exit-modal-buttons">
                <button type="button" class="action-btn secondary" id="stayButton">
                    <span class="bee-icon" aria-hidden="true">🐝</span>
                    Keep Practicing!
                </button>
                <button type="button" class="action-btn exit" id="confirmExitButton">
                    <span class="bee-icon" aria-hidden="true">🏠</span>
                    Go to Menu
                </button>
            </div>
        </div>
    </div>

    <!-- iOS Voice Intro Modal -->
    <div class="voice-intro-modal" id="voiceIntroModal" style="display: none;">
        <div class="voice-intro-content">
            <div class="voice-intro-icon">🐝🎤</div>
            <h2>Meet Buzzy, Your Announcer Bee!</h2>
            <p>Hi there! I'm Buzzy and I'll be announcing your quiz today!</p>
            <p>🔊 Tap below to enable my voice and start the quiz with audio announcements.</p>
            <p style="font-size: 0.9rem; color: #666; margin-top: 1rem;">
                💡 You can mute me anytime using the button below the quiz area.
            </p>
            <div class="voice-intro-buttons">
                <button type="button" class="action-btn primary" id="enableVoiceBtn">
                    <span class="bee-icon" aria-hidden="true">🔊</span>
                    Start with Buzzy's Voice
                </button>
                <button type="button" class="action-btn secondary" id="skipVoiceBtn">
                    <span class="bee-icon" aria-hidden="true">🔇</span>
                    Start Silent (No Voice)
                </button>
            </div>
        </div>
    </div>
</div>

<!-- 3D Bee Swarm Canvas -->
<canvas id="beeSwarmCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 3;"></canvas>

{% endblock %}

<!-- Progress Tracker OUTSIDE content block - truly fixed -->
<div class="progress-tracker">
    <div class="honey-jar">
        <div id="honeyLevel" style="position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, #FFB300 0%, #FFC107 50%, #FFD54F 100%); border-radius: 0 0 14px 14px; height: 0%; transition: height 0.6s ease, box-shadow 0.6s ease; box-shadow: 0 -4px 15px rgba(255, 179, 0, 0.5);"></div>
    </div>
    <div class="progress-description">
        Fill the honey jar as you spell correctly! 🍯
    </div>
</div>

{% block extra_js %}
<script>
// Frontend safety blanker - hide target word if it appears in definitions/sentences
function hideTargetWord(text, word) {
    if (!text || !word) return text || '';
    const esc = word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(new RegExp(`\\b${esc}\\b`, 'gi'), '_____');
}

class BeeSoundboard {
    constructor() {
        this.supported = typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined';
        this.ctx = null;
        this.unlocked = false;
        this.cachedVoice = null; // Cache voice for consistency
        this.setupUnlock();
    }

    setupUnlock() {
        if (!this.supported || this.unlocked) {
            return;
        }

        const unlock = () => {
            if (!this.supported) {
                return;
            }
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!this.ctx && Ctx) {
                this.ctx = new Ctx();
            }
            if (this.ctx && this.ctx.state === 'suspended') {
                this.ctx.resume();
            }
            this.unlocked = true;
            document.removeEventListener('pointerdown', unlock, true);
            document.removeEventListener('keydown', unlock, true);
        };

        document.addEventListener('pointerdown', unlock, true);
        document.addEventListener('keydown', unlock, true);
    }

    play(type) {
        if (!this.supported || !this.ctx || !this.unlocked) {
            return;
        }

        switch (type) {
            case 'correct':
                this.sequence([
                    { freq: 660, duration: 0.16, gain: 0.18, wave: 'sine', fade: true },
                    { freq: 880, duration: 0.2, gain: 0.16, wave: 'triangle', fade: true, delay: 0.12 },
                    { freq: 990, duration: 0.22, gain: 0.12, wave: 'sine', fade: true, delay: 0.14 }
                ]);
                break;
            case 'incorrect':
                this.sequence([
                    { freq: 220, duration: 0.24, gain: 0.22, wave: 'sawtooth', slide: 150, fade: true },
                    { freq: 180, duration: 0.18, gain: 0.15, wave: 'triangle', fade: true, delay: 0.08 }
                ]);
                break;
            case 'skip':
                this.sequence([
                    { freq: 320, duration: 0.16, gain: 0.14, wave: 'triangle', fade: true },
                    { freq: 260, duration: 0.18, gain: 0.12, wave: 'sine', fade: true, delay: 0.08 }
                ]);
                break;
            case 'speak':
                this.sequence([
                    { freq: 480, duration: 0.14, gain: 0.12, wave: 'sine', fade: true },
                    { freq: 720, duration: 0.18, gain: 0.1, wave: 'triangle', fade: true, delay: 0.1 }
                ]);
                break;
            case 'button-hover':
                this.sequence([
                    { freq: 600, duration: 0.08, gain: 0.08, wave: 'sine', fade: true }
                ]);
                break;
            case 'button-click':
                this.sequence([
                    { freq: 800, duration: 0.06, gain: 0.1, wave: 'triangle', fade: true },
                    { freq: 1000, duration: 0.08, gain: 0.08, wave: 'sine', fade: true, delay: 0.02 }
                ]);
                break;
            case 'button-primary':
                this.sequence([
                    { freq: 880, duration: 0.1, gain: 0.12, wave: 'triangle', fade: true },
                    { freq: 1320, duration: 0.12, gain: 0.1, wave: 'sine', fade: true, delay: 0.05 }
                ]);
                break;
            case 'buzz-hover':
                // Quick buzz sound on hover
                this.sequence([
                    { freq: 220, duration: 0.05, gain: 0.08, wave: 'sawtooth', fade: true }
                ]);
                break;
            case 'buzz-click':
                // Satisfying buzz click
                this.sequence([
                    { freq: 440, duration: 0.08, gain: 0.15, wave: 'triangle', fade: true },
                    { freq: 550, duration: 0.06, gain: 0.12, wave: 'sine', fade: true, delay: 0.04 }
                ]);
                break;
            case 'honey-collect':
                // Sweet honey collection sound
                this.sequence([
                    { freq: 660, duration: 0.1, gain: 0.1, wave: 'sine' },
                    { freq: 880, duration: 0.12, gain: 0.12, wave: 'triangle', fade: true, delay: 0.08 }
                ]);
                break;
        }
    }

    sequence(steps) {
        if (!this.ctx) {
            return;
        }

        let start = this.ctx.currentTime;
        steps.forEach((step) => {
            const duration = step.duration ?? 0.2;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();

            osc.type = step.wave || 'sine';
            osc.frequency.setValueAtTime(step.freq, start);
            if (typeof step.slide === 'number') {
                osc.frequency.linearRampToValueAtTime(step.slide, start + duration);
            }

            const gainValue = Math.max(step.gain ?? 0.14, 0.0001);
            gain.gain.setValueAtTime(gainValue, start);
            if (step.fade) {
                gain.gain.exponentialRampToValueAtTime(0.0001, start + duration);
            }

            osc.connect(gain);
            gain.connect(this.ctx.destination);

            osc.start(start);
            osc.stop(start + duration + 0.01);

            start += step.delay ?? duration;
        });
    }

    speakWord(word, onEndCallback = null) {
        if (!word || !('speechSynthesis' in window)) {
            if (onEndCallback) onEndCallback();
            return;
        }
        
        speechSynthesis.cancel();
        
        const speak = () => {
            const utterance = new SpeechSynthesisUtterance(word);
            utterance.pitch = 1.35;
            utterance.rate = 0.92;
            utterance.volume = 0.9;
            utterance.text = word;
            
            // Visualizer elements
            const visualizer = document.getElementById('voiceVisualizer');
            const statusEl = document.getElementById('voiceStatus');
            
            // Add event listeners for voice visualizer
            if (onEndCallback) {
                utterance.addEventListener('end', onEndCallback);
                utterance.addEventListener('error', onEndCallback);
            }
            
            // Use enhanced voice selection for natural-sounding female voices
            if (!this.cachedVoice) {
                this.cachedVoice = this.selectBestFemaleVoice();
                
                if (this.cachedVoice) {
                    console.log('🎤 speakWord using enhanced voice:', this.cachedVoice.name, this.cachedVoice.lang, 
                               'Quality:', this.cachedVoice.quality || 'default', 
                               'Local:', this.cachedVoice.localService);
                } else {
                    console.warn('⚠️ speakWord: No suitable voice found, using browser default');
                }
            }
            
            if (this.cachedVoice) {
                utterance.voice = this.cachedVoice;
            }
            
            // Sync visual display with announcer
            utterance.onstart = () => {
                if (visualizer) visualizer.classList.add('speaking');
                if (statusEl) statusEl.textContent = this.cachedVoice
                    ? `🎙️ Speaking (${this.cachedVoice.lang} • ${this.cachedVoice.name})`
                    : '🎙️ Speaking';
            };
            
            utterance.onboundary = (event) => {
                // Word-level micro pauses for natural cadence
                if (event.name === 'word' || event.charLength > 0) {
                    if (visualizer) {
                        visualizer.classList.remove('speaking');
                        visualizer.classList.add('pausing', 'word-pulse');
                        setTimeout(() => {
                            visualizer.classList.remove('pausing', 'word-pulse');
                            visualizer.classList.add('speaking');
                        }, 150);
                    }
                }
                // Longer pause at sentence punctuation
                const char = (utterance.text || '').charAt(event.charIndex || 0);
                if (char === ',' || char === ';' || char === '.' || char === '!' || char === '?') {
                    if (visualizer) {
                        visualizer.classList.remove('speaking');
                        visualizer.classList.add('pausing');
                        setTimeout(() => {
                            visualizer.classList.remove('pausing');
                            visualizer.classList.add('speaking');
                        }, 400);
                    }
                }
            };
            
            utterance.onend = () => {
                if (visualizer) visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
                if (statusEl) statusEl.textContent = '🐝 Ready';
            };
            
            utterance.onerror = () => {
                if (visualizer) visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
                if (statusEl) statusEl.textContent = '⚠️ Voice error';
            };

            try {
                speechSynthesis.speak(utterance);
            } catch (err) {
                console.error('speechSynthesis.speak failed:', err);
                if (onEndCallback) onEndCallback();
            }
        };
        
        // iOS Safari fix: Better voice loading with timeout
        const voices = speechSynthesis.getVoices();
        if (voices.length > 0) {
            speak();
        } else {
            // iOS often needs a delay
            let timeout = setTimeout(() => {
                console.warn('⚠️ Voice loading timeout - speaking anyway');
                speak();
            }, 2000);
            
            speechSynthesis.addEventListener('voiceschanged', () => {
                clearTimeout(timeout);
                speak();
            }, { once: true });
        }
    }
}

// ⏱️ Countdown Timer Class - Honey Jar Animation
class CountdownTimer {
    constructor(duration = 15, options = {}) {
        this.duration = duration;
        this.remaining = duration;
        this.interval = null;
        this.isPaused = false;
        
        // Callbacks
        this.onComplete = options.onComplete || null;
        this.onTick = options.onTick || null;
        this.onWarning = options.onWarning || null;
        this.onCritical = options.onCritical || null;
        
        // Settings
        this.warningThreshold = options.warningThreshold || 5;
        this.criticalThreshold = options.criticalThreshold || 3;
        this.soundEnabled = options.soundEnabled !== false; // Default true
        
        // DOM elements
        this.container = document.getElementById('countdownContainer');
        this.jarTimer = document.getElementById('honeyJarTimer');
        this.honeyFill = document.getElementById('honeyFill');
        this.timerNumber = document.getElementById('timerNumber');
        
        // State flags
        this.hasWarned = false;
        this.hasCritical = false;
    }
    
    start() {
        console.log('⏱️ Starting countdown timer:', this.duration + 's');
        
        // Reset state
        this.remaining = this.duration;
        this.hasWarned = false;
        this.hasCritical = false;
        
        // Show timer with animation
        this.container.classList.remove('hidden');
        setTimeout(() => {
            this.container.classList.add('active');
        }, 50);
        
        // Reset jar appearance
        this.jarTimer.classList.remove('warning', 'critical', 'expired');
        
        // Initial display
        this.updateDisplay();
        
        // Start countdown
        this.interval = setInterval(() => {
            if (this.isPaused) return;
            
            this.remaining--;
            this.updateDisplay();
            
            // Callbacks
            if (this.onTick) {
                this.onTick(this.remaining);
            }
            
            // Warning zone (5 seconds)
            if (this.remaining === this.warningThreshold && !this.hasWarned) {
                this.triggerWarning();
                this.hasWarned = true;
            }
            
            // Critical zone (3 seconds)
            if (this.remaining === this.criticalThreshold && !this.hasCritical) {
                this.triggerCritical();
                this.hasCritical = true;
            }
            
            // Time's up
            if (this.remaining <= 0) {
                this.stop();
                this.triggerExpired();
                
                if (this.onComplete) {
                    this.onComplete();
                }
            }
        }, 1000);
    }
    
    updateDisplay() {
        // Update honey level (percentage)
        const percentage = Math.max(0, (this.remaining / this.duration) * 100);
        this.honeyFill.style.height = `${percentage}%`;
        
        // Update number
        this.timerNumber.textContent = Math.max(0, this.remaining);
        
        // Color coding based on time remaining
        if (this.remaining <= 0) {
            this.jarTimer.classList.remove('warning', 'critical');
            this.jarTimer.classList.add('expired');
        } else if (this.remaining <= this.criticalThreshold) {
            this.jarTimer.classList.remove('warning');
            this.jarTimer.classList.add('critical');
        } else if (this.remaining <= this.warningThreshold) {
            this.jarTimer.classList.remove('critical');
            this.jarTimer.classList.add('warning');
        } else {
            this.jarTimer.classList.remove('warning', 'critical', 'expired');
        }
    }
    
    triggerWarning() {
        console.log('⚠️ Timer warning: ' + this.remaining + 's left');
        
        if (this.onWarning) {
            this.onWarning(this.remaining);
        }
    }
    
    triggerCritical() {
        console.log('🚨 Timer critical: ' + this.remaining + 's left');
        
        // Play gentle buzz sound
        if (this.soundEnabled) {
            this.playBuzzSound();
        }
        
        if (this.onCritical) {
            this.onCritical(this.remaining);
        }
    }
    
    triggerExpired() {
        console.log('⏰ Timer expired!');
        
        // Optional longer buzz for time's up
        if (this.soundEnabled) {
            this.playBuzzSound(0.3); // Slightly longer buzz
        }
    }
    
    playBuzzSound(duration = 0.15) {
        try {
            // Use Web Audio API for gentle "bzz" sound
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            // Low frequency buzz (bee-like)
            oscillator.frequency.value = 180;
            oscillator.type = 'sawtooth'; // Buzzy sound
            
            // Gentle volume
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 0.02); // Fade in
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration); // Fade out
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        } catch (err) {
            console.warn('Buzz sound failed:', err);
        }
    }
    
    pause() {
        this.isPaused = true;
        console.log('⏸️ Timer paused');
    }
    
    resume() {
        this.isPaused = false;
        console.log('▶️ Timer resumed');
    }
    
    stop() {
        if (this.interval) {
            clearInterval(this.interval);
            this.interval = null;
        }
        console.log('⏹️ Timer stopped');
    }
    
    reset() {
        this.stop();
        this.remaining = this.duration;
        this.hasWarned = false;
        this.hasCritical = false;
        this.updateDisplay();
    }
    
    hide() {
        this.container.classList.remove('active');
        setTimeout(() => {
            this.container.classList.add('hidden');
        }, 300);
    }
    
    destroy() {
        this.stop();
        this.hide();
    }
}

class BeeDelightManager {
    constructor() {
        this.quizCard = document.getElementById('quizCard');
        this.inputWrapper = document.getElementById('beeInputWrapper');
        this.feedbackArea = document.getElementById('feedbackArea');
        this.phoneticHint = document.getElementById('phoneticHint');
        this.honeyFill = document.getElementById('honeyFill');
        this.mascot = document.getElementById('beeMascot');
        this.soundboard = new BeeSoundboard();
        this.totalQuestions = 0;
        this.mascotTimer = null;
        this.reducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        this.cursorTrailLast = 0;

        this.registerButtonSparkles();
        this.registerCursorTrail();
        this.setupButtonEffects();
        this.setupExitQuiz();
    }

    setupExitQuiz() {
        const exitButton = document.getElementById('exitQuizButton');
        const exitModal = document.getElementById('exitModal');
        const stayButton = document.getElementById('stayButton');
        const confirmExitButton = document.getElementById('confirmExitButton');

        // Show exit confirmation modal
        exitButton?.addEventListener('click', () => {
            this.showExitModal();
        });

        // Stay and continue practicing
        stayButton?.addEventListener('click', () => {
            this.hideExitModal();
            this.soundboard.play('button-primary');
        });

        // Confirm exit and go to menu
        confirmExitButton?.addEventListener('click', () => {
            this.confirmExit();
        });

        // Close modal on backdrop click
        exitModal?.addEventListener('click', (e) => {
            if (e.target === exitModal) {
                this.hideExitModal();
            }
        });
    }

    showExitModal() {
        const exitModal = document.getElementById('exitModal');
        const exitStats = document.getElementById('exitStats');
        
        // Update stats in the modal
        const correctCount = document.getElementById('correctCount')?.textContent || '0';
        const incorrectCount = document.getElementById('incorrectCount')?.textContent || '0';
        const streakCount = document.getElementById('streakCount')?.textContent || '0';
        
        exitStats.innerHTML = `
            <div>📝 Words spelled: ${parseInt(correctCount) + parseInt(incorrectCount)}</div>
            <div>✅ Correct answers: ${correctCount}</div>
            <div>🔥 Current streak: ${streakCount}</div>
        `;
        
        exitModal.style.display = 'flex';
        this.soundboard.play('button-hover');
    }

    hideExitModal() {
        const exitModal = document.getElementById('exitModal');
        exitModal.style.display = 'none';
    }

    confirmExit() {
        this.soundboard.play('success');
        
        // Add a friendly exit message
        const exitModal = document.getElementById('exitModal');
        const modalContent = exitModal.querySelector('.exit-modal-content');
        
        modalContent.innerHTML = `
            <div class="exit-modal-header">
                <h3>🌟 Great job spelling today!</h3>
            </div>
            <div class="exit-modal-body">
                <p>🐝 You're becoming a spelling superstar!</p>
                <p>Come back anytime to practice more words!</p>
            </div>
        `;
        
        // Redirect after a short delay
        setTimeout(() => {
            window.location.href = '/';
        }, 2000);
    }

    setupButtonEffects() {
        // Add sound and visual effects to all action buttons
        const buttons = document.querySelectorAll('.action-btn');
        buttons.forEach((button) => {
            // Hover effects
            button.addEventListener('mouseenter', () => {
                this.soundboard.play('button-hover');
            });

            // Click effects
            button.addEventListener('click', (event) => {
                if (button.classList.contains('primary')) {
                    this.soundboard.play('button-primary');
                    this.addButtonEffect(button, 'ripple-effect');
                } else if (button.classList.contains('exit')) {
                    this.soundboard.play('button-click');
                    this.addButtonEffect(button, 'buzz-effect');
                } else {
                    this.soundboard.play('button-click');
                    this.addButtonEffect(button, 'buzz-effect');
                }
                
                // Add sparkle magic on button press
                if (!this.reducedMotion) {
                    this.createSparkleBurst(button);
                }
            });
        });
    }

    addButtonEffect(button, effectClass) {
        button.classList.add(effectClass);
        setTimeout(() => {
            button.classList.remove(effectClass);
        }, 400);
    }

    registerButtonSparkles() {
        const buttons = document.querySelectorAll('.quiz-buttons .quiz-button');
        buttons.forEach((button) => {
            button.addEventListener('click', () => {
                if (!this.reducedMotion) {
                    this.createSparkleBurst(button);
                }
            });
        });
    }

    registerCursorTrail() {
        if (this.reducedMotion) {
            return;
        }

        document.addEventListener('pointermove', (event) => {
            const now = performance.now();
            if (now - this.cursorTrailLast < 60) {
                return;
            }
            this.cursorTrailLast = now;

            const trail = document.createElement('div');
            trail.className = 'cursor-trail';
            trail.style.left = `${event.clientX - 9}px`;
            trail.style.top = `${event.clientY - 9}px`;
            document.body.appendChild(trail);
            setTimeout(() => trail.remove(), 600);
        });
    }

    setTotalQuestions(total) {
        if (Number.isFinite(total) && total > 0) {
            this.totalQuestions = total;
        }
    }

    updateProgress(progress = {}) {
        if (!this.honeyFill) {
            return;
        }

        const total = progress.total ?? this.totalQuestions;
        if (Number.isFinite(total) && total > 0) {
            this.totalQuestions = total;
        }

        const workingTotal = this.totalQuestions || total;
        if (!workingTotal) {
            return;
        }

        const correct = Math.max(progress.correct ?? 0, 0);
        const ratio = Math.min(correct / workingTotal, 1);
        const height = 12 + ratio * 78;
        this.honeyFill.style.height = `${Math.max(12, Math.round(height))}%`;
    }

    handleDefinition() {
        this.showPhonetic('');
        this.clearFeedbackState();
    }

    handlePronounce(data, onEndCallback = null) {
        this.soundboard.play('speak');
        if (data?.word) {
            // Speak a friendly prompt and the word twice
            const phrase = `Spell the word ${data.word}. ${data.word}.`;
            this.soundboard.speakWord(phrase, onEndCallback);
        } else if (onEndCallback) {
            onEndCallback();
        }
        this.setMascotState('speaking', 1600);
        const speakButton = document.getElementById('speakButton');
        if (!this.reducedMotion && speakButton) {
            this.createSparkleBurst(speakButton, 7);
        }
    }

    handleFeedback(result) {
        if (!this.quizCard) {
            return;
        }

        this.quizCard.classList.remove('correct', 'incorrect');
        this.quizCard.classList.add('quiz-feedback');

        if (result.correct) {
            this.quizCard.classList.add('correct');
            this.soundboard.play('correct');
            this.setMascotState('happy', 1700);
            if (!this.reducedMotion) {
                this.createSparkleBurst(this.inputWrapper || this.quizCard, 8);
            }
            this.showPhonetic('');
        } else {
            this.quizCard.classList.add('incorrect');
            this.soundboard.play(result.skipped ? 'skip' : 'incorrect');
            this.setMascotState(result.skipped ? 'speaking' : 'sad', result.skipped ? 1000 : 1400);
            if (result.phonetic_spelling) {
                this.showPhonetic(result.phonetic_spelling);
            } else if (result.phonetic) {
                this.showPhonetic(result.phonetic);
            }
        }
    }

    handleSkip() {
        this.soundboard.play('skip');
        this.setMascotState('sad', 1000);
    }

    showPhonetic(text) {
        if (!this.phoneticHint) {
            return;
        }

        if (!text) {
            this.phoneticHint.textContent = '';
            this.phoneticHint.classList.add('hidden');
            return;
        }

        this.phoneticHint.textContent = `Phonetic: ${text}`;
        this.phoneticHint.classList.remove('hidden');
    }

    clearFeedbackState() {
        if (this.quizCard) {
            this.quizCard.classList.remove('quiz-feedback', 'correct', 'incorrect');
        }
    }

    setMascotState(state, duration = 1500) {
        if (!this.mascot) {
            return;
        }

        const classes = {
            happy: 'is-happy',
            sad: 'is-sad',
            speaking: 'is-speaking'
        };

        Object.values(classes).forEach(cls => this.mascot.classList.remove(cls));

        if (state && classes[state]) {
            this.mascot.classList.add(classes[state]);
            clearTimeout(this.mascotTimer);
            if (duration > 0) {
                this.mascotTimer = setTimeout(() => {
                    this.mascot?.classList.remove(classes[state]);
                }, duration);
            }
        }
    }

    createSparkleBurst(target, count = 8) {
        if (!target) {
            return;
        }
        const rect = target.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        for (let i = 0; i < count; i++) {
            const sparkle = document.createElement('div');
            sparkle.className = 'sparkle';
            
            // Create more magical spread pattern
            const angle = (i / count) * Math.PI * 2;
            const distance = 30 + Math.random() * 40;
            const offsetX = Math.cos(angle) * distance + (Math.random() - 0.5) * 20;
            const offsetY = Math.sin(angle) * distance + (Math.random() - 0.5) * 20;
            
            sparkle.style.left = `${centerX + offsetX}px`;
            sparkle.style.top = `${centerY + offsetY}px`;
            
            // Add random sparkle colors
            const colors = ['#FFD700', '#FFA500', '#FFE082', '#FFEB3B', '#FFF59D'];
            const randomColor = colors[Math.floor(Math.random() * colors.length)];
            sparkle.style.setProperty('--sparkle-color', randomColor);
            
            // Add random delay for more magical effect
            sparkle.style.animationDelay = `${Math.random() * 0.3}s`;
            
            document.body.appendChild(sparkle);
            setTimeout(() => sparkle.remove(), 900);
        }
    }
}

class QuizManager {
    constructor(options = {}) {
        this.delight = options.delight || null;
        this.smartyBee = options.smartyBee || null;
        this.isAnswering = false;
        this.lastPronounceData = null;
        this.currentWordData = null;
        this.totalWords = 0;
        this.quizStarted = false;
        
        // ⏱️ Countdown Timer Settings (Updated to 60s with auto-advance)
        this.timerEnabled = true; // Can be toggled in settings
        this.timerDuration = 60; // Default 60 seconds
        this.timerMode = 'normal'; // 'easy' (90s), 'normal' (60s), 'challenge' (30s), 'dynamic'
        this.timerStrictMode = true; // Auto-advance when time expires (changed from false)
        this.countdownTimer = null;
        
        // 🏆 Points System Settings
        this.pointsEnabled = true; // Enable points tracking
        this.sessionPoints = 0; // Total points for current session
        this.currentStreak = 0; // Consecutive correct answers
        this.maxStreak = 0; // Best streak this session
        
        // 💡 Hint tracking for current word
        this.hintUsedThisWord = false; // Track if hint was used for current word
        
        // Get student name - prioritize server-provided name for logged-in users
        {% if user_name %}
        this.studentName = {{ user_name|tojson }};
        // Save to localStorage for consistency
        localStorage.setItem('studentName', this.studentName);
        console.log('👤 Using logged-in user name:', this.studentName);
        {% else %}
        this.studentName = localStorage.getItem('studentName') || '';
        console.log('👤 Using localStorage name:', this.studentName);
        {% endif %}
        
        // Reset honey jar to 0% at start
        this.resetHoneyJar();
        
        // Randomized positive feedback messages (without names - we'll add dynamically)
        this.positiveFeedback = [
            "🐝 BEE-utiful! That's absolutely correct!",
            "🍯 Sweet spelling! You nailed it!",
            "✨ Buzz-tastic! Perfect spelling!",
            "🌟 Honey of a job! You got it!",
            "🎯 Bulls-bee! Spelled perfectly!",
            "💛 Golden! That's the right spelling!",
            "🐝 Bee-lieve it! You're amazing!",
            "🏆 Hive five! Excellent work!",
            "⭐ Un-bee-lievable! That's correct!",
            "🍯 Sweet success! Well done!",
            "🎉 Buzz worthy! Perfect spelling!",
            "🌺 Bee-autiful work! Correct!",
            "💪 Bee strong! You aced it!",
            "🎊 What a honey! Fantastic!",
            "🌈 Spectacular spelling!",
            "🐝 Brilliant! Absolutely brilliant!",
            "🍯 You're on fire! Keep it up!",
            "⭐ Magnificent spelling!",
            "🎯 Perfect! Just perfect!"
        ];
        
        // Randomized negative feedback messages (without names - we'll add dynamically)
        this.negativeFeedback = [
            "🐝 Oops! That's not quite right. Try again!",
            "🍯 Not quite! Don't worry, even bees make mistakes!",
            "💫 Almost there! Give it another buzz!",
            "🌸 Not this time! Keep trying, you can do it!",
            "🐝 Whoops! Let's try that spelling again!",
            "🎯 Not quite hitting the hive! Try once more!",
            "🌟 Close, but not quite! You've got this!",
            "🐝 Bee-lieve in yourself and try again!",
            "💛 That's not it, but don't give up!",
            "🍯 Sweeter spelling needed! Give it another go!",
            "🌺 Not the right buzz! Try again!",
            "🎪 Oopsie-daisy! Let's spell it again!",
            "🐝 Buzz! That's incorrect, but keep going!",
            "💫 Not quite right! You can do this!",
            "🌟 Almost! Give it another try!",
            "🍯 Nice try! Let's practice more!",
            "🐝 That's okay! Learning is a journey!",
            "💫 Keep buzzing! You'll get it!"
        ];
        
        // ⏱️ Randomized timer start announcements
        this.timerStartAnnouncements = [
            "Your 60 seconds to spell the word begins now!",
            "Ready? Your timer starts now!",
            "The clock is ticking! 60 seconds begins now!",
            "Let's see how fast you can spell this! Timer starting!",
            "You have 60 seconds! Go!",
            "Timer activated! Spell away!",
            "The honey jar is draining! Start spelling!",
            "60 seconds on the clock! Begin!",
            "Time's running! Spell the word now!",
            "Your countdown begins right now!",
            "The timer has started! Good luck!",
            "60 seconds to show your spelling skills! Go!",
            "Clock's ticking! Let's spell!",
            "Timer's rolling! Start spelling!",
            "You're on the clock! 60 seconds!"
        ];
        
        // Audio announcements for correct answers (name removed to avoid repetition)
        this.correctAnnouncements = [
            "Fantastic! That's absolutely correct!",
            "Excellent spelling! You're doing great!",
            "Perfect! You got it right!",
            "Amazing work! That's correct!",
            "Brilliant! You spelled it perfectly!",
            "Wonderful! That's the right spelling!",
            "Outstanding! You're a spelling star!",
            "Superb! You nailed that word!",
            "Marvelous! Correct spelling!",
            "Spectacular! You're on fire!"
        ];
        
        // Audio announcements for incorrect answers (name removed to avoid repetition)
        this.incorrectAnnouncements = [
            "Not quite right, but don't give up!",
            "That's not it, but keep trying!",
            "Oops, let's try that again!",
            "Not this time, but you're learning!",
            "Almost there! Give it another try!",
            "That's not the spelling, but keep going!",
            "Nice try! Let's practice more!",
            "Not quite, but you're getting closer!",
            "That's okay! Every mistake helps us learn!",
            "Keep trying! You'll get it next time!"
        ];

        // Voice announcer settings
        this.announcerEnabled = localStorage.getItem('announcerEnabled') !== 'false'; // Default ON
        this.voiceUnlocked = false; // iOS requires user interaction
        this.isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        this.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        
        console.log('🎤 Voice System Initialization:');
        console.log('   - announcerEnabled:', this.announcerEnabled);
        console.log('   - voiceUnlocked:', this.voiceUnlocked);
        console.log('   - isIOS:', this.isIOS);
        console.log('   - isSafari:', this.isSafari);
        console.log('   - localStorage announcerEnabled:', localStorage.getItem('announcerEnabled'));
        
        this.initializeEventListeners();
        
        // Show iOS voice intro modal if needed, otherwise show regular intro
        if ((this.isIOS || this.isSafari) && !sessionStorage.getItem('voiceIntroShown')) {
            console.log('📱 Showing iOS/Safari voice intro modal');
            this.updateVoiceToggleUI(); // Initialize UI to match state
            this.showVoiceIntroModal();
        } else {
            console.log('💻 Desktop/Non-iOS browser detected - voice unlocked immediately');
            this.voiceUnlocked = true; // Non-iOS can use voice immediately
            this.updateVoiceToggleUI(); // Initialize UI to match state
            this.showIntroAnnouncer();
        }
    }
    
    // Helper function to remove emojis and special characters for speech
    cleanTextForSpeech(text) {
        // Remove emojis and special symbols, keep only letters, numbers, punctuation
        return text.replace(/[\u{1F300}-\u{1F9FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]/gu, '').trim();
    }
    
    // Enhanced voice selection algorithm for natural-sounding female voices
    selectBestFemaleVoice() {
        const voices = speechSynthesis.getVoices();
        console.log('🎤 Analyzing', voices.length, 'available voices for best female selection');
        
        // Score voices based on multiple criteria
        const scoredVoices = voices
            .filter(voice => voice.lang.startsWith('en')) // English only
            .map(voice => {
                let score = 0;
                const name = voice.name.toLowerCase();
                
                // Language preference (US English gets highest priority)
                if (voice.lang === 'en-US') score += 100;
                else if (voice.lang.startsWith('en-')) score += 50;
                
                // Quality indicators (higher quality = more natural)
                if (voice.quality === 'high') score += 50;
                else if (voice.quality === 'enhanced') score += 40;
                else if (voice.quality === 'normal') score += 20;
                
                // Local voices often sound more natural than cloud-based
                if (voice.localService) score += 30;
                
                // Explicit female voice indicators
                if (name.includes('female')) score += 80;
                if (name.includes('woman')) score += 80;
                
                // Premium/Natural voice names (typically higher quality)
                if (name.includes('natural')) score += 60;
                if (name.includes('premium')) score += 60;
                if (name.includes('neural')) score += 60;
                
                // Known high-quality female voices (ordered by naturalness)
                const premiumVoices = {
                    'samantha': 90,     // macOS - very natural
                    'alex': 85,         // macOS - excellent quality
                    'victoria': 80,     // Windows - natural sounding
                    'zira': 75,         // Windows - clear and natural
                    'aria': 85,         // Modern Windows neural
                    'jenny': 85,        // Modern neural voice
                    'nova': 80,         // Modern neural voice
                    'allison': 70,      // Traditional but good
                    'ava': 70,          // Traditional but good
                    'joanna': 65,       // Amazon Polly style
                    'susan': 60,        // Traditional
                    'karen': 55,        // Traditional
                    'moira': 50         // Traditional Irish
                };
                
                // Check for premium voice names
                for (const [voiceName, points] of Object.entries(premiumVoices)) {
                    if (name.includes(voiceName)) {
                        score += points;
                        break;
                    }
                }
                
                // Avoid robotic or synthetic-sounding voices
                if (name.includes('robot')) score -= 50;
                if (name.includes('synthetic')) score -= 30;
                if (name.includes('microsoft') && !name.includes('aria')) score -= 10; // Modern MS voices are better
                
                // Log voice evaluation for debugging
                console.log(`🎤 Voice: ${voice.name} (${voice.lang}) - Score: ${score}`, {
                    quality: voice.quality || 'default',
                    local: voice.localService,
                    voiceURI: voice.voiceURI
                });
                
                return { voice, score };
            })
            .sort((a, b) => b.score - a.score); // Sort by highest score first
        
        if (scoredVoices.length > 0) {
            const bestVoice = scoredVoices[0].voice;
            console.log(`🏆 Selected best voice: ${bestVoice.name} (${bestVoice.lang}) with score ${scoredVoices[0].score}`);
            console.log(`   Quality: ${bestVoice.quality || 'default'}, Local: ${bestVoice.localService}, URI: ${bestVoice.voiceURI}`);
            return bestVoice;
        }
        
        console.warn('⚠️ No suitable female voice found in', voices.length, 'available voices');
        return null;
    }
    
    speakAnnouncement(text) {
        // Check if announcer is enabled
        if (!this.announcerEnabled) {
            console.log('🔇 Announcer is muted');
            return Promise.resolve(); // Return resolved promise immediately
        }
        
        // Check if voice is unlocked (important for iOS)
        if ((this.isIOS || this.isSafari) && !this.voiceUnlocked) {
            console.log('🔒 Voice not unlocked on iOS - skipping announcement');
            return Promise.resolve();
        }
        
        // Clean text by removing emojis before speaking
        const cleanText = this.cleanTextForSpeech(text);
        
        // Get visualizer elements
        const visualizer = document.getElementById('voiceVisualizer');
        const status = document.getElementById('voiceStatus');
        
        // Start visualizer animation
        if (visualizer && status) {
            console.log('🎤 Starting voice visualizer for announcement');
            visualizer.classList.add('speaking');
            status.textContent = '🗣️ Speaking...';
        }
        
        // Return a promise that resolves when speech is done
        return new Promise((resolve) => {
            // Use Web Speech API to announce results
            if (!('speechSynthesis' in window)) {
                // Stop visualizer if no speech synthesis
                if (visualizer && status) {
                    visualizer.classList.remove('speaking');
                    status.textContent = '🐝 Ready';
                }
                resolve(); // If no speech synthesis, resolve immediately
                return;
            }
            
            // Function to speak with the selected voice
            const speak = () => {
                const utterance = new SpeechSynthesisUtterance(cleanText);
                utterance.rate = 1.0;  // Normal speed for US English
                utterance.pitch = 1.1;
                utterance.volume = 0.85;
                
                // Cache the selected voice to ensure consistency using enhanced selection
                if (!this.cachedVoice) {
                    this.cachedVoice = this.selectBestFemaleVoice();
                    
                    if (this.cachedVoice) {
                        const voiceType = this.cachedVoice.lang === 'en-US' 
                            ? '🎤 Enhanced US Female' : '🗣️ Enhanced Female English';
                        console.log(`🎤 Selected enhanced voice for session: ${this.cachedVoice.name} (${this.cachedVoice.lang}) [${voiceType}]`);
                    } else {
                        console.warn('⚠️ No suitable enhanced female voice found, using browser default');
                    }
                }
                
                if (this.cachedVoice) {
                    utterance.voice = this.cachedVoice;
                }
                
                // Word boundary event - pulse animation on each word with natural pauses
                utterance.onboundary = (event) => {
                    if (!visualizer) return;
                    
                    // Pulse effect on word boundaries with brief natural pause
                    if (event.name === 'word') {
                        console.log('🎤 Word boundary:', event.charIndex);
                        visualizer.classList.add('word-pulse');
                        // Briefly switch from speaking→pausing→speaking for a visible dip
                        visualizer.classList.remove('speaking');
                        visualizer.classList.add('pausing');
                        setTimeout(() => {
                            visualizer.classList.remove('pausing', 'word-pulse');
                            visualizer.classList.add('speaking');
                        }, 130);
                    }
                    
                    // Natural pause on sentence boundaries (longer, amber bars)
                    const utterText = (utterance.text || '');
                    const ch = utterText.charAt(event.charIndex);
                    if (ch === '.' || ch === '!' || ch === '?' || event.name === 'sentence') {
                        console.log('🎤 Sentence boundary - natural pause');
                        visualizer.classList.remove('speaking');
                        visualizer.classList.add('pausing');
                        setTimeout(() => {
                            visualizer.classList.remove('pausing');
                            visualizer.classList.add('speaking');
                        }, 400);
                    }
                };
                
                // Add event listener for when speech actually starts
                utterance.onstart = () => {
                    console.log('🎤 Speech started - activating visualizer');
                    if (visualizer && status) {
                        visualizer.classList.add('speaking');
                        status.textContent = '🗣️ Speaking...';
                    }
                };
                
                // Add event listeners to resolve promise when speech ends
                utterance.onend = () => {
                    console.log('✅ Speech finished');
                    // Stop visualizer animation
                    if (visualizer && status) {
                        console.log('🎤 Stopping voice visualizer for announcement');
                        visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
                        status.textContent = '🐝 Ready';
                    }
                    resolve();
                };
                
                utterance.onerror = (event) => {
                    console.warn('⚠️ Speech error:', event.error);
                    // Stop visualizer animation on error
                    if (visualizer && status) {
                        visualizer.classList.remove('speaking', 'word-pulse', 'pausing');
                        status.textContent = '🐝 Ready';
                    }
                    resolve(); // Resolve even on error to prevent blocking
                };
                
                speechSynthesis.speak(utterance);
            };
            
            // Ensure voices are loaded
            if (speechSynthesis.getVoices().length > 0) {
                speak();
            } else {
                speechSynthesis.addEventListener('voiceschanged', speak, { once: true });
            }
        });
    }
    
    createExplosion() {
        // Create buzz-worthy explosion effect for correct answers
        const container = document.createElement('div');
        container.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 9999;
        `;
        
        // Create multiple particles
        const particleCount = 30;
        const emojis = ['🐝', '🍯', '⭐', '✨', '💛', '🌟', '🎉', '🎊'];
        
        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            const emoji = emojis[Math.floor(Math.random() * emojis.length)];
            const angle = (Math.PI * 2 * i) / particleCount;
            const velocity = 100 + Math.random() * 100;
            const tx = Math.cos(angle) * velocity;
            const ty = Math.sin(angle) * velocity;
            
            particle.textContent = emoji;
            particle.style.cssText = `
                position: absolute;
                font-size: ${20 + Math.random() * 20}px;
                left: 0;
                top: 0;
                animation: explode 1s ease-out forwards;
                --tx: ${tx}px;
                --ty: ${ty}px;
            `;
            
            container.appendChild(particle);
        }
        
        document.body.appendChild(container);
        
        // Remove after animation
        setTimeout(() => container.remove(), 1000);
    }
    
    showIntroAnnouncer() {
        const feedbackArea = document.getElementById('feedbackArea');
        feedbackArea.style.display = 'block';
        feedbackArea.className = 'feedback-area feedback-success';
        
        // Check if mobile device (mobile autoplay policies can block speech)
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Mobile gets "Tap to Start" button for better control
        if (isMobile) {
            // Check if iOS device
            const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
            
            if (isIOS) {
                // 🍎 iOS-specific intro with "Tap to Hear Voice" button
                feedbackArea.innerHTML = `
                    <div style="font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem;">
                        🐝 Welcome to BeeSmart Spelling! 🐝
                    </div>
                    <div style="margin-bottom: 1.5rem; color: #666; font-size: 1.1rem;">
                        I'm Buzzy, your announcer bee! 🍯
                    </div>
                    <div style="margin-bottom: 1.2rem;">
                        <button id="iosVoiceBtn" style="
                            background: linear-gradient(135deg, #4CAF50, #45a049);
                            border: 3px solid #388E3C;
                            border-radius: 15px;
                            padding: 15px 30px;
                            font-size: 1.2rem;
                            font-weight: 700;
                            color: white;
                            cursor: pointer;
                            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
                            min-height: 44px;
                            width: 85%;
                            max-width: 300px;
                            touch-action: manipulation;
                        ">
                            � Tap to Hear My Voice
                        </button>
                    </div>
                    <div id="iosVoiceStatus" style="margin: 1rem 0; font-size: 0.95rem; color: #666;">
                        Then we'll start spelling!
                    </div>
                    <div style="margin-top: 0.5rem;">
                        <button id="skipVoiceBtn" style="
                            background: transparent;
                            border: 2px solid #ccc;
                            border-radius: 10px;
                            padding: 10px 20px;
                            font-size: 0.9rem;
                            color: #666;
                            cursor: pointer;
                            min-height: 44px;
                            touch-action: manipulation;
                        ">
                            Skip Intro (Start Now)
                        </button>
                    </div>
                `;
            } else {
                // Android/other mobile - standard tap to start
                feedbackArea.innerHTML = `
                    <div style="font-size: 1.2rem; font-weight: 700;">
                        �🐝 Welcome to BeeSmart Spelling! 🐝
                    </div>
                    <div style="margin-top: 0.8rem;">
                        🍯 I'm your announcer bee, Buzzy! 🍯
                    </div>
                    <div style="margin-top: 0.5rem;">
                        🌟 Listen carefully to each word, then spell it correctly! 🌟
                    </div>
                    <div style="margin-top: 1.2rem;">
                        <button id="startQuizBtn" style="
                            background: linear-gradient(135deg, #FFD700, #FFA500);
                            border: 3px solid #FF8C00;
                            border-radius: 15px;
                            padding: 15px 30px;
                            font-size: 1.3rem;
                            font-weight: 700;
                            color: #2C1810;
                            cursor: pointer;
                            box-shadow: 0 4px 15px rgba(255, 165, 0, 0.4);
                            min-height: 44px;
                            min-width: 200px;
                            touch-action: manipulation;
                        ">
                            🚀 Tap to Start! 🚀
                        </button>
                    </div>
                    <div id="voiceStatusMessage" style="margin-top: 1rem; font-size: 0.9rem; color: #666;"></div>
                `;
            }
            
            // 🍎 iOS-specific handlers
            if (isIOS) {
                // iOS Voice Button Handler
                const iosVoiceBtn = document.getElementById('iosVoiceBtn');
                const iosVoiceStatus = document.getElementById('iosVoiceStatus');
                const skipVoiceBtn = document.getElementById('skipVoiceBtn');
                
                iosVoiceBtn.addEventListener('click', () => {
                    console.log('🍎 iOS user tapped to hear intro voice');
                    
                    // 🍎 CRITICAL: Unlock voice for iOS - this enables all subsequent voice announcements
                    this.voiceUnlocked = true;
                    console.log('✅ Voice unlocked for iOS!');
                    
                    iosVoiceBtn.disabled = true;
                    iosVoiceBtn.style.opacity = '0.6';
                    iosVoiceBtn.style.cursor = 'not-allowed';
                    iosVoiceStatus.textContent = '🎤 Buzzy is speaking...';
                    iosVoiceStatus.style.color = '#4CAF50';
                    iosVoiceStatus.style.fontWeight = '600';
                    
                    const greeting = this.studentName ? `Hello ${this.studentName}!` : "Hello!";
                    const introMessage = `${greeting} I'm Buzzy, your announcer bee! ` +
                                       "Listen carefully to each word, then spell what you hear. " +
                                       "Let's start spelling and fill that honey jar!";
                    
                    // 🍎 CRITICAL: Create and speak IMMEDIATELY (iOS autoplay requirement)
                    speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(introMessage);
                    utterance.rate = 0.95;
                    utterance.pitch = 1.1;
                    utterance.volume = 0.9;
                    
                    utterance.onend = () => {
                        console.log('✅ iOS intro voice completed successfully');
                        iosVoiceStatus.textContent = '✅ Great! Starting quiz...';
                        iosVoiceStatus.style.color = '#4CAF50';
                        
                        setTimeout(() => {
                            feedbackArea.style.display = 'none';
                            this.quizStarted = true;
                            this.loadNextWordWithIntro();
                        }, 800);
                    };
                    
                    utterance.onerror = (err) => {
                        console.error('❌ iOS voice failed:', err);
                        iosVoiceStatus.textContent = '⚠️ Voice unavailable - starting quiz anyway!';
                        iosVoiceStatus.style.color = '#ff9800';
                        
                        setTimeout(() => {
                            feedbackArea.style.display = 'none';
                            this.quizStarted = true;
                            this.loadNextWordWithIntro();
                        }, 1500);
                    };
                    
                    // 🍎 Speak immediately while in user gesture context
                    speechSynthesis.speak(utterance);
                    
                }, { once: true });
                
                // iOS Skip Button Handler
                skipVoiceBtn.addEventListener('click', () => {
                    console.log('🍎 iOS user skipped voice intro');
                    
                    // 🍎 CRITICAL: Still need to unlock voice even if skipped
                    this.voiceUnlocked = true;
                    console.log('✅ Voice unlocked for iOS (via skip)!');
                    
                    feedbackArea.style.display = 'none';
                    this.quizStarted = true;
                    this.loadNextWordWithIntro();
                }, { once: true });
                
            } else {
                // Android/other mobile - Add click handler for start button
                document.getElementById('startQuizBtn').addEventListener('click', () => {
                    console.log('📱 Android/mobile user tapped to start quiz');
                    const startBtn = document.getElementById('startQuizBtn');
                    const statusMsg = document.getElementById('voiceStatusMessage');
                    
                    // Disable button during voice playback
                    if (startBtn) {
                        startBtn.disabled = true;
                        startBtn.style.opacity = '0.6';
                        startBtn.style.cursor = 'not-allowed';
                    }
                    
                    // Android voice intro
                    if ('speechSynthesis' in window) {
                        const greeting = this.studentName ? `Hello ${this.studentName}!` : "Hello!";
                        const introMessage = `${greeting} I'm Buzzy, your announcer bee! Let's start spelling!`;
                        
                        statusMsg.textContent = '🎤 Playing intro...';
                        
                        // Start speech and handle completion
                        this.speakAnnouncement(introMessage)
                            .then(() => {
                                console.log('✅ Voice intro completed successfully on Android');
                                statusMsg.textContent = '✅ Ready!';
                                
                                // Start quiz after voice completes
                                setTimeout(() => {
                                    feedbackArea.style.display = 'none';
                                    this.quizStarted = true;
                                    this.loadNextWordWithIntro();
                                }, 300);
                            })
                            .catch((err) => {
                                console.error('❌ Voice intro failed on Android:', err);
                                statusMsg.textContent = '⚠️ Voice unavailable, but quiz will continue';
                                statusMsg.style.color = '#ff9800';
                                
                                // Continue anyway
                                setTimeout(() => {
                                    feedbackArea.style.display = 'none';
                                    this.quizStarted = true;
                                    this.loadNextWordWithIntro();
                                }, 1000);
                            });
                    } else {
                        // No speech synthesis support
                        console.warn('⚠️ Speech synthesis not supported on this Android device');
                        statusMsg.textContent = '⚠️ Voice not available on this device';
                        statusMsg.style.color = '#ff9800';
                        
                        // Start quiz anyway after brief delay
                        setTimeout(() => {
                            feedbackArea.style.display = 'none';
                            this.quizStarted = true;
                            this.loadNextWordWithIntro();
                        }, 1500);
                    }
                }, { once: true });
            }
            
        } else {
            // Desktop gets auto-advancing intro with voice
            feedbackArea.innerHTML = `
                <div style="font-size: 1.2rem; font-weight: 700;">
                    🐝 Welcome to BeeSmart Spelling! 🐝
                </div>
                <div style="margin-top: 0.8rem;">
                    🍯 I'm your announcer bee, Buzzy! 🍯
                </div>
                <div style="margin-top: 0.5rem;">
                    🌟 Listen carefully to each word, then spell it correctly! 🌟
                </div>
                <div style="margin-top: 0.8rem; font-size: 1.1rem;">
                    ✨ Get ready for your first word! ✨
                </div>
            `;
            
            // Desktop voice intro
            if ('speechSynthesis' in window) {
                const greeting = this.studentName ? `Hello ${this.studentName}!` : "Hello!";
                const introMessage = `${greeting} I'm Buzzy, your announcer bee! Welcome to BeeSmart Spelling! ` +
                                   "Listen carefully to each word, then type what you hear. " +
                                   "Spell correctly to fill your honey jar with sweet success!";
                
                const speakIntro = () => {
                    console.log('🎤 Buzzy is ready to speak! Available voices:', speechSynthesis.getVoices().length);
                    
                    // iOS fix: Force voice loading by creating a dummy utterance first
                    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
                    if (isIOS) {
                        console.log('🍎 iOS detected - preloading voices');
                        const dummyUtterance = new SpeechSynthesisUtterance('');
                        speechSynthesis.speak(dummyUtterance);
                        speechSynthesis.cancel();
                    }
                    
                    this.speakAnnouncement(introMessage).catch(err => {
                        console.warn('Voice intro failed:', err);
                    });
                };
                
                if (speechSynthesis.getVoices().length > 0) {
                    speakIntro();
                } else {
                    speechSynthesis.addEventListener('voiceschanged', speakIntro, { once: true });
                }
            }
            
            // Auto-advance after 7 seconds on desktop
            setTimeout(() => {
                feedbackArea.style.display = 'none';
                this.quizStarted = true;
                this.loadNextWordWithIntro();
            }, 7000);
        }
    }
    
    async loadNextWordWithIntro() {
        try {
            this.lastPronounceData = null;
            // Reset hint tracking for new word
            this.hintUsedThisWord = false;
            
            const response = await fetch('/api/next', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            const data = await response.json();

            if (response.status !== 200 || data.error) {
                console.error('API Error:', data);
                BeeSmart.showError(data.message || data.error || 'Failed to load the next word');
                return;
            }

            if (data.done) {
                this.showQuizComplete(data.summary);
                return;
            }

            const questionNumber = data.index ?? data.number ?? 1;
            this.totalWords = data.total ?? this.totalWords;
            document.getElementById('progressText').textContent = `Question ${questionNumber} of ${data.total ?? '?'}`;

            if (data.progress) {
                this.updateScoreDisplay({ ...data.progress, total: data.total });
            }

            this.delight?.setTotalQuestions(data.total);

            // Set the definition with fallback - prefer explicit sentence/hint fields
            const defBox = document.getElementById('definitionDisplay');
            console.log('DEBUG loadNextWordWithIntro: /api/next response:', {
                sentence: data.sentence,
                hint: data.hint,
                definition: data.definition,
                word: data.word,
                fullData: data
            });
            
            let chosen = '';
            if (data.sentence) {
                console.log('✓ Using sentence:', data.sentence);
                chosen = data.sentence;
            } else if (data.hint) {
                console.log('✓ Using hint:', data.hint);
                chosen = `Hint: ${data.hint}`;
            } else if (data.definition) {
                console.log('✓ Using definition:', data.definition);
                chosen = data.definition;
            } else {
                console.log('⚠️ No definition found, attempting /api/pronounce fallback');
                // Last resort fallback: try /api/pronounce for sentence/hint
                const pronounce = await this.fetchPronounce(true);
                chosen =
                    (pronounce && (pronounce.sentence || pronounce.hint))
                        ? (pronounce.sentence || `Hint: ${pronounce.hint}`)
                        : 'Listen carefully and spell the word you hear.';
                console.log('Using fallback:', chosen);
            }
            
            // Apply safety blanker to hide target word if it appears in the definition
            defBox.textContent = hideTargetWord(chosen, data.word);

            // Store the word data
            this.currentWordData = {
                word: data.word || '',
                sentence: data.sentence || '',
                definition: data.definition || ''
            };

            this.enableInput();
            document.getElementById('spellingInput').value = '';
            document.getElementById('spellingInput').focus();

            // If this first question is also the last, announce that explicitly
            if (data.total && questionNumber === data.total) {
                const namePart = (this.studentName || '').trim();
                const preface = namePart ? `${namePart}, this is your last word.` : `This is your last word.`;
                await this.speakAnnouncement(preface);
            }
            // ⏱️ Announce word FIRST, then insert a short pause and auto‑pronounce before timer
            const firstWordIntro = `Your first word is: ${data.word}`;
            
            // Wait for word announcement to complete
            await this.speakAnnouncement(firstWordIntro);
            
            // Brief visual pause between phases
            {
                const visualizer = document.getElementById('voiceVisualizer');
                const status = document.getElementById('voiceStatus');
                if (visualizer && status) {
                    visualizer.classList.add('pausing');
                    status.textContent = '⏸️ Pause...';
                }
                await new Promise(r => setTimeout(r, 500));
                if (visualizer && status) {
                    visualizer.classList.remove('pausing');
                }
            }
            
            // Auto‑pronounce the word (so kids hear it clearly before timing)
            await this.pronounceWord({ refresh: true });
            
            // Then announce timer start and actually start the timer
            if (this.timerEnabled && this.quizStarted) {
                await this.announceAndStartTimer();
            }
            
            // Show "Can't hear?" helper notification after first word loads
            if (this.announcerEnabled && questionNumber === 1) {
                this.showVoiceHelperNotification();
            }

        } catch (error) {
            console.error('Error loading word:', error);
            BeeSmart.showError('Error loading word. Please try again.');
        }
    }
    
    // ⏱️ Countdown Timer Methods
    async announceAndStartTimer() {
        // Get random timer start announcement
        const announcement = this.getRandomTimerStartAnnouncement();
        
        console.log('⏱️ Announcing timer start:', announcement);
        
        // Announce the timer start
        await this.speakAnnouncement(announcement);
        
        // Small pause for clarity (0.3 seconds)
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // NOW start the actual timer
        this.startCountdownTimer();
    }
    
    getRandomTimerStartAnnouncement() {
        const announcements = this.timerStartAnnouncements;
        const randomIndex = Math.floor(Math.random() * announcements.length);
        let announcement = announcements[randomIndex];
        
        // Replace "15 seconds" with actual duration dynamically
        const duration = this.getTimerDuration();
        announcement = announcement.replace(/15 seconds?/gi, `${duration} ${duration === 1 ? 'second' : 'seconds'}`);
        
        return announcement;
    }
    
    startCountdownTimer() {
        // Stop any existing timer (but don't hide it - we're restarting)
        if (this.countdownTimer) {
            this.countdownTimer.stop();
        }
        
        // Get timer duration based on mode
        const duration = this.getTimerDuration();
        
        console.log(`⏱️ Starting ${duration}s countdown timer (mode: ${this.timerMode})`);
        
        // Create new timer
        this.countdownTimer = new CountdownTimer(duration, {
            onComplete: () => this.handleTimerExpired(),
            onWarning: (remaining) => console.log(`⚠️ Warning: ${remaining}s left`),
            onCritical: (remaining) => console.log(`🚨 Critical: ${remaining}s left`),
            soundEnabled: true,
            warningThreshold: 5,
            criticalThreshold: 3
        });
        
        // Start the timer
        this.countdownTimer.start();
    }
    
    getTimerDuration() {
        // Dynamic mode: adjust time based on word length
        if (this.timerMode === 'dynamic' && this.currentWordData && this.currentWordData.word) {
            const wordLength = this.currentWordData.word.length;
            if (wordLength <= 5) return 10;
            if (wordLength <= 9) return 15;
            return 20;
        }
        
        // Preset modes (Updated for 60s system)
        const durations = {
            'easy': 90,      // 90 seconds for easy mode
            'normal': 60,    // 60 seconds for normal mode  
            'challenge': 30  // 30 seconds for challenge mode
        };
        
        return durations[this.timerMode] || 60; // Default to 60s
    }
    
    handleTimerExpired() {
        console.log('⏰ Timer expired! Auto-advancing to next word...');
        
        // Mark as incorrect/missed
        this.incorrectCount++;
        this.currentStreak = 0; // Reset streak
        
        // Show timeout message
        const feedbackArea = document.getElementById('feedbackArea');
        feedbackArea.className = 'feedback-area feedback-error';
        feedbackArea.style.display = 'block';
        feedbackArea.textContent = '⏰ Time\'s up! Moving to the next word... (Marked as missed)';
        
        // Speak the timeout message
        this.speakAnnouncement('Times up! Moving to the next word.');
        
        // Update stats display
        this.updateStats();
        
        // Wait 3 seconds, then auto-advance to next word
        setTimeout(() => {
            this.loadNextWord();
        }, 3000);
    }
    
    stopCountdownTimer() {
        if (this.countdownTimer) {
            this.countdownTimer.stop();
        }
    }
    
    pauseCountdownTimer() {
        if (this.countdownTimer) {
            this.countdownTimer.pause();
        }
    }
    
    resumeCountdownTimer() {
        if (this.countdownTimer) {
            this.countdownTimer.resume();
        }
    }
    
    // 🏆 Points Calculation System
    calculatePoints(word, timeRemaining, isFirstAttempt, hintsUsed) {
        if (!this.pointsEnabled) return 0;
        
        const basePoints = 100;
        
        // Time bonus: 0-100 points based on time remaining
        const timeBonus = Math.floor((timeRemaining / this.timerDuration) * 100);
        
        // Difficulty multiplier based on word length
        let difficultyMultiplier = 1.0;
        const wordLength = word.length;
        if (wordLength >= 13) {
            difficultyMultiplier = 2.5;  // Very long words
        } else if (wordLength >= 9) {
            difficultyMultiplier = 2.0;  // Long words
        } else if (wordLength >= 6) {
            difficultyMultiplier = 1.5;  // Medium words
        } else {
            difficultyMultiplier = 1.0;  // Short words
        }
        
        // Calculate subtotal with multiplier
        let points = (basePoints + timeBonus) * difficultyMultiplier;
        
        // Add bonuses
        if (isFirstAttempt) {
            points += 50;  // First attempt bonus
        }
        
        // Hint penalty: Reduce points by 30% if hint was used
        if (hintsUsed) {
            const hintPenalty = Math.floor(points * 0.3); // 30% penalty
            points -= hintPenalty;
            console.log(`💡 Hint penalty applied: -${hintPenalty} points (30% reduction)`);
        } else {
            points += 25;  // No hints bonus
        }
        
        // Streak bonus
        points += this.currentStreak * 10;
        
        return Math.floor(points);
    }
    
    // Display points earned
    displayPointsEarned(points, breakdown) {
        const feedbackArea = document.getElementById('feedbackArea');
        
        // Create detailed points breakdown
        let pointsHtml = '<div style="background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); padding: 20px; border-radius: 15px; margin: 15px 0; color: #4A2C2A;">';
        pointsHtml += '<h3 style="margin: 0 0 15px 0; font-size: 1.3em;">🎯 Points Earned!</h3>';
        pointsHtml += '<div style="background: rgba(255,255,255,0.3); padding: 15px; border-radius: 10px; text-align: left;">';
        pointsHtml += `<div style="margin: 5px 0;">📊 Base: ${breakdown.base} points</div>`;
        pointsHtml += `<div style="margin: 5px 0;">⏱️ Time Bonus: ${breakdown.timeBonus} points</div>`;
        if (breakdown.difficulty > 1.0) {
            pointsHtml += `<div style="margin: 5px 0;">💪 Difficulty: ×${breakdown.difficulty}</div>`;
        }
        if (breakdown.firstAttempt) {
            pointsHtml += `<div style="margin: 5px 0;">🎯 First Attempt: +50 points</div>`;
        }
        if (breakdown.hintPenalty && breakdown.hintPenalty > 0) {
            pointsHtml += `<div style="margin: 5px 0; color: #FF6B00;">💡 Hint Used: -${breakdown.hintPenalty} points (30% penalty)</div>`;
        } else if (breakdown.noHints) {
            pointsHtml += `<div style="margin: 5px 0;">🧠 No Hints: +25 points</div>`;
        }
        if (breakdown.streakBonus > 0) {
            pointsHtml += `<div style="margin: 5px 0;">🔥 Streak Bonus: +${breakdown.streakBonus} points</div>`;
        }
        pointsHtml += '<hr style="margin: 10px 0; border: 1px solid rgba(74,44,42,0.3);">';
        pointsHtml += `<div style="font-size: 1.5em; font-weight: bold; margin-top: 10px;">💰 Total: ${points} points!</div>`;
        pointsHtml += '</div>';
        pointsHtml += `<div style="margin-top: 15px; font-size: 1.1em;">🏆 Session Total: ${this.sessionPoints} points</div>`;
        pointsHtml += '</div>';
        
        const currentFeedback = feedbackArea.innerHTML;
        feedbackArea.innerHTML = currentFeedback + pointsHtml;
    }
    
    // 🍯 Show animated points popup
    showPointsPopup(points, breakdown) {
        // Remove any existing popup
        const existingPopup = document.querySelector('.points-popup');
        if (existingPopup) {
            existingPopup.remove();
        }
        
        // Create popup element
        const popup = document.createElement('div');
        popup.className = 'points-popup';
        
        // Build breakdown HTML
        let breakdownHTML = '';
        if (breakdown.base) {
            breakdownHTML += `<div class="points-breakdown-item"><span>Base</span><span>+${breakdown.base}</span></div>`;
        }
        if (breakdown.time_bonus) {
            breakdownHTML += `<div class="points-breakdown-item"><span>⏱️ Time Bonus</span><span>+${breakdown.time_bonus}</span></div>`;
        }
        if (breakdown.streak_bonus) {
            breakdownHTML += `<div class="points-breakdown-item"><span>🔥 Streak</span><span>+${breakdown.streak_bonus}</span></div>`;
        }
        if (breakdown.first_attempt) {
            breakdownHTML += `<div class="points-breakdown-item"><span>🎯 First Try</span><span>+${breakdown.first_attempt}</span></div>`;
        }
        if (breakdown.hint_penalty && breakdown.hint_penalty > 0) {
            breakdownHTML += `<div class="points-breakdown-item" style="color: #FF6B00;"><span>💡 Hint Used</span><span>-${breakdown.hint_penalty}</span></div>`;
        } else if (breakdown.no_hints) {
            breakdownHTML += `<div class="points-breakdown-item"><span>🧠 No Hints</span><span>+${breakdown.no_hints}</span></div>`;
        }
        
        popup.innerHTML = `
            <div class="points-total">+${points}</div>
            ${breakdownHTML ? `<div class="points-breakdown">${breakdownHTML}</div>` : ''}
        `;
        
        document.body.appendChild(popup);
        
        // Auto-remove after animation completes (2.5s)
        setTimeout(() => {
            popup.remove();
        }, 2500);
        
        console.log(`🍯 Displayed points popup: +${points} points`);
    }
    
    // 🏆 Badge Achievement System
    createConfetti() {
        const colors = ['#FFD700', '#FFA500', '#FF6B6B', '#4ECDC4', '#95E1D3', '#F38181'];
        const confettiCount = 50;
        
        for (let i = 0; i < confettiCount; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.top = '-10px';
            confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
            
            document.body.appendChild(confetti);
            
            // Remove after animation completes
            setTimeout(() => confetti.remove(), 3000);
        }
    }
    
    async showBadgeUnlock(badge) {
        return new Promise((resolve) => {
            // Create confetti effect
            this.createConfetti();
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'badge-modal';
            
            modal.innerHTML = `
                <div class="badge-modal-content">
                    <div class="badge-icon">${badge.icon}</div>
                    <h2>Achievement Unlocked!</h2>
                    <h3>${badge.name}</h3>
                    <p>${badge.message}</p>
                    <p class="badge-points">+${badge.points} Bonus Points!</p>
                    <button class="badge-continue-btn" onclick="this.closest('.badge-modal').remove()">
                        Continue
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Speak achievement
            this.speakAnnouncement(`Achievement unlocked! ${badge.name}! You earned ${badge.points} bonus points!`);
            
            // Auto-continue after 5 seconds (in case user doesn't click)
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    modal.remove();
                    resolve();
                }
            }, 5000);
            
            // Manual continue button
            modal.querySelector('.badge-continue-btn').addEventListener('click', () => {
                modal.remove();
                resolve();
            });
            
            console.log(`🏆 Badge unlocked: ${badge.name} (+${badge.points} points)`);
        });
    }
    
    async showAllBadges(badges) {
        console.log(`🏆 Showing ${badges.length} badge(s)`);
        
        for (const badge of badges) {
            await this.showBadgeUnlock(badge);
            // Small delay between badges if multiple
            if (badges.indexOf(badge) < badges.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
    }
    
    // 🎯 Level Progression System
    async showLevelUp(levelUpData) {
        return new Promise((resolve) => {
            // Create massive confetti explosion!
            this.createConfetti();
            setTimeout(() => this.createConfetti(), 300);
            setTimeout(() => this.createConfetti(), 600);
            
            // Create modal
            const modal = document.createElement('div');
            modal.className = 'level-up-modal';
            
            const newLevel = levelUpData.new_level;
            const oldLevel = levelUpData.old_level;
            
            modal.innerHTML = `
                <div class="level-up-content">
                    <div class="level-up-title">🎉 LEVEL UP! 🎉</div>
                    <div class="level-up-icon-large">${newLevel.icon}</div>
                    <div class="level-up-tier">${newLevel.tier}</div>
                    <div class="level-up-message">${levelUpData.message}</div>
                    <div class="level-progress-display">
                        <p><strong>${oldLevel.tier}</strong> ${oldLevel.icon} → <strong>${newLevel.tier}</strong> ${newLevel.icon}</p>
                        <p>Level ${oldLevel.level} → Level ${newLevel.level}</p>
                        <p>🏆 ${newLevel.points_current.toLocaleString()} Total Points</p>
                        ${newLevel.is_max_level ? 
                            '<p style="color: #D32F2F; font-weight: 800;">👑 MAX LEVEL REACHED! 👑</p>' : 
                            `<p>Next: ${newLevel.points_to_next.toLocaleString()} points to next level</p>`
                        }
                    </div>
                    <button class="level-continue-btn">
                        Awesome! Let's Continue!
                    </button>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Speak level up
            this.speakAnnouncement(`Amazing! You leveled up! You are now a ${newLevel.tier}!`);
            
            // Auto-continue after 8 seconds
            setTimeout(() => {
                if (document.body.contains(modal)) {
                    modal.remove();
                    resolve();
                }
            }, 8000);
            
            // Manual continue button
            modal.querySelector('.level-continue-btn').addEventListener('click', () => {
                modal.remove();
                resolve();
            });
            
            console.log(`🎯 Level up! ${oldLevel.tier} (Lv ${oldLevel.level}) → ${newLevel.tier} (Lv ${newLevel.level})`);
        });
    }
    
    getRandomFeedback(isCorrect) {
        const feedbackArray = isCorrect ? this.positiveFeedback : this.negativeFeedback;
        const randomIndex = Math.floor(Math.random() * feedbackArray.length);
        let feedback = feedbackArray[randomIndex];
        
        // Randomly add student name (15% chance - more sporadic) at the beginning, middle, or end
        if (this.studentName && Math.random() < 0.15) {
            const position = Math.floor(Math.random() * 3); // 0, 1, or 2
            const nameVariations = [
                this.studentName,
                `${this.studentName}!`,
                this.studentName
            ];
            const chosenName = nameVariations[Math.floor(Math.random() * nameVariations.length)];
            
            if (position === 0) {
                // Add at beginning: "Sarah, 🐝 BEE-utiful!..."
                feedback = `${chosenName}, ${feedback.charAt(0).toLowerCase()}${feedback.slice(1)}`;
            } else if (position === 1) {
                // Add in middle after first sentence
                const sentences = feedback.split('!');
                if (sentences.length > 1) {
                    feedback = `${sentences[0]}! ${chosenName}, ${sentences.slice(1).join('!').trim()}`;
                } else {
                    // Fallback to beginning if no second sentence
                    feedback = `${chosenName}, ${feedback}`;
                }
            } else {
                // Add at end: "...Perfect spelling, Sarah!"
                feedback = feedback.replace(/!$/, `, ${chosenName}!`);
            }
        }
        
        return feedback;
    }
    
    getRandomAudioAnnouncement(isCorrect) {
        const announcementArray = isCorrect ? this.correctAnnouncements : this.incorrectAnnouncements;
        const randomIndex = Math.floor(Math.random() * announcementArray.length);
        const base = announcementArray[randomIndex];

        // Occasionally personalize with name; mostly do it with a deliberate pause
        // between the phrase and the name so it sounds natural.
        if (this.studentName && Math.random() < 0.12) { // ~12% of the time
            // 70%: split into two utterances (phrase, then name after a short pause)
            if (Math.random() < 0.7) {
                return {
                    phrase: base,               // speak the core message first
                    name: this.studentName,     // then speak just the name
                    pauseMs: 380                // ~0.38s pause feels natural with our cadence
                };
            }
            // 30%: inline the name for variety (fallback to commas)
            if (Math.random() < 0.5) {
                return `${this.studentName}, ${base.charAt(0).toLowerCase()}${base.slice(1)}`;
            } else {
                return base.replace(/!$/, `, ${this.studentName}!`);
            }
        }

        return base;
    }

    initializeEventListeners() {
        const spellingInput = document.getElementById('spellingInput');
        const submitButton = document.getElementById('submitButton');
        const speakButton = document.getElementById('speakButton');
        const repeatButton = document.getElementById('repeatButton');
        const getHintButton = document.getElementById('getHintButton');
        const skipButton = document.getElementById('skipButton');
        const restartButton = document.getElementById('restartButton');

        // Add buzz sounds to all buttons
        const allButtons = [submitButton, speakButton, repeatButton, getHintButton, skipButton, restartButton];
        allButtons.forEach(button => {
            if (button) {
                // Hover sound
                button.addEventListener('mouseenter', () => {
                    this.soundboard?.play('buzz-hover');
                });
                
                // Click sound
                button.addEventListener('mousedown', () => {
                    this.soundboard?.play('buzz-click');
                });
            }
        });

        submitButton.addEventListener('click', () => {
            try { window.BeeVoiceViz?.react('submit'); } catch (e) {}
            this.submitAnswer();
        });
        spellingInput.addEventListener('keyup', (event) => {
            if (event.key === 'Enter' && !this.isAnswering) {
                try { window.BeeVoiceViz?.react('submit'); } catch (e) {}
                this.submitAnswer();
            }
        });

        if (speakButton) {
            speakButton.addEventListener('click', () => {
                try { window.BeeVoiceViz?.react('button'); } catch (e) {}
                this.pronounceWord();
            });
        }

        if (repeatButton) {
            repeatButton.addEventListener('click', () => {
                try { window.BeeVoiceViz?.react('button'); } catch (e) {}
                this.pronounceWord();
            });
        }

        getHintButton.addEventListener('click', () => {
            try { window.BeeVoiceViz?.react('hint'); } catch (e) {}
            this.getDefinition({ refresh: true });
        });
        skipButton.addEventListener('click', () => {
            try { window.BeeVoiceViz?.react('skip'); } catch (e) {}
            this.skipWord();
        });
        restartButton.addEventListener('click', () => this.restartQuiz());

        // Voice toggle button
        const voiceToggleBtn = document.getElementById('voiceToggleBtn');
        if (voiceToggleBtn) {
            voiceToggleBtn.addEventListener('click', () => this.toggleAnnouncer());
        }

        spellingInput.focus();
    }

    // Show voice intro modal for iOS/Safari
    showVoiceIntroModal() {
        const modal = document.getElementById('voiceIntroModal');
        const enableVoiceBtn = document.getElementById('enableVoiceBtn');
        const skipVoiceBtn = document.getElementById('skipVoiceBtn');
        
        if (!modal) return;
        
        modal.style.display = 'flex';
        
        // Enable voice button - unlocks voice and starts quiz with intro
        enableVoiceBtn.addEventListener('click', () => {
            this.voiceUnlocked = true;
            this.announcerEnabled = true;
            localStorage.setItem('announcerEnabled', 'true');
            sessionStorage.setItem('voiceIntroShown', 'true');
            modal.style.display = 'none';
            this.updateVoiceToggleUI();
            this.showIntroAnnouncer();
        }, { once: true });
        
        // Skip voice button - disables announcer and starts quiz silently
        skipVoiceBtn.addEventListener('click', () => {
            this.voiceUnlocked = false;
            this.announcerEnabled = false;
            localStorage.setItem('announcerEnabled', 'false');
            sessionStorage.setItem('voiceIntroShown', 'true');
            modal.style.display = 'none';
            this.updateVoiceToggleUI();
            // Don't call showIntroAnnouncer - just start quiz silently
            this.loadNextWord();
        }, { once: true });
    }

    // Toggle announcer voice on/off
    toggleAnnouncer() {
        this.announcerEnabled = !this.announcerEnabled;
        localStorage.setItem('announcerEnabled', this.announcerEnabled ? 'true' : 'false');
        
        // If enabling on iOS and not unlocked, we need user interaction to unlock
        if (this.announcerEnabled && (this.isIOS || this.isSafari) && !this.voiceUnlocked) {
            // Unlock voice with a test utterance
            const testUtterance = new SpeechSynthesisUtterance('');
            window.speechSynthesis.speak(testUtterance);
            this.voiceUnlocked = true;
        }
        
        this.updateVoiceToggleUI();
        
        // Show feedback
        const message = this.announcerEnabled ? 
            "🔊 Buzzy's voice is ON! I'll announce your results!" : 
            "🔇 Buzzy's voice is OFF. Quiz will be silent.";
        BeeSmart.showSuccess(message);
    }

    // Update voice toggle button UI
    updateVoiceToggleUI() {
        const icon = document.getElementById('voiceToggleIcon');
        const text = document.getElementById('voiceToggleText');
        
        if (icon && text) {
            if (this.announcerEnabled) {
                icon.textContent = '🔊';
                text.textContent = 'Mute Buzzy';
            } else {
                icon.textContent = '🔇';
                text.textContent = 'Unmute Buzzy';
            }
        }
    }

    // Show helper notification if user can't hear announcer
    showVoiceHelperNotification() {
        // Don't show if already dismissed this session
        if (sessionStorage.getItem('voiceHelperDismissed')) {
            return;
        }
        
        const notification = document.createElement('div');
        notification.id = 'voiceHelperNotification';
        notification.style.cssText = `
            position: fixed;
            top: 120px;
            right: 20px;
            background: linear-gradient(135deg, #FF6B00 0%, #FFD700 100%);
            color: white;
            padding: 1.5rem;
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(255, 107, 0, 0.4);
            border: 3px solid rgba(255, 255, 255, 0.3);
            z-index: 1500;
            max-width: 320px;
            animation: slideInRight 0.5s ease-out;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Arial Rounded MT Bold', sans-serif;
        `;
        
        notification.innerHTML = `
            <div style="display: flex; align-items: flex-start; gap: 1rem;">
                <div style="font-size: 2.5rem;">🔊</div>
                <div style="flex: 1;">
                    <div style="font-size: 1.1rem; font-weight: 700; margin-bottom: 0.5rem; text-shadow: 1px 1px 2px rgba(0,0,0,0.2);">
                        Can't hear Buzzy?
                    </div>
                    <div style="font-size: 0.95rem; margin-bottom: 1rem; line-height: 1.4;">
                        If you can't hear the announcer, tap the <strong>Mute/Unmute button</strong> below the quiz to enable voice!
                    </div>
                    <button id="dismissVoiceHelper" style="
                        background: white;
                        color: #FF6B00;
                        border: none;
                        border-radius: 8px;
                        padding: 8px 16px;
                        font-size: 0.9rem;
                        font-weight: 600;
                        cursor: pointer;
                        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                        width: 100%;
                    ">
                        Got it! 👍
                    </button>
                </div>
            </div>
        `;
        
        document.body.appendChild(notification);
        
        // Add slide-in animation
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from {
                    transform: translateX(400px);
                    opacity: 0;
                }
                to {
                    transform: translateX(0);
                    opacity: 1;
                }
            }
            @keyframes slideOutRight {
                from {
                    transform: translateX(0);
                    opacity: 1;
                }
                to {
                    transform: translateX(400px);
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
        
        // Dismiss button handler
        document.getElementById('dismissVoiceHelper').addEventListener('click', () => {
            sessionStorage.setItem('voiceHelperDismissed', 'true');
            notification.style.animation = 'slideOutRight 0.3s ease-in';
            setTimeout(() => notification.remove(), 300);
        });
        
        // Auto-dismiss after 12 seconds
        setTimeout(() => {
            if (notification.parentElement) {
                sessionStorage.setItem('voiceHelperDismissed', 'true');
                notification.style.animation = 'slideOutRight 0.3s ease-in';
                setTimeout(() => notification.remove(), 300);
            }
        }, 12000);
    }

    async loadNextWord() {
        try {
            this.lastPronounceData = null;
            // Reset hint tracking for new word
            this.hintUsedThisWord = false;
            
            const response = await fetch('/api/next', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            const data = await response.json();

            if (response.status !== 200 || data.error) {
                console.error('API Error:', data);
                BeeSmart.showError(data.message || data.error || 'Failed to load the next word');
                return;
            }

            if (data.done) {
                // Announce quiz ending before showing report card
                await this.announceQuizEnding();
                this.showQuizComplete(data.summary);
                return;
            }

            const questionNumber = data.index ?? data.number ?? 1;
            this.totalWords = data.total ?? this.totalWords;
            document.getElementById('progressText').textContent = `Question ${questionNumber} of ${data.total ?? '?'}`;

            if (data.progress) {
                this.updateScoreDisplay({ ...data.progress, total: data.total });
            }

            this.delight?.setTotalQuestions(data.total);

            // Set the definition directly from the /api/next response - prefer explicit fields
            const defBox = document.getElementById('definitionDisplay');
            console.log('DEBUG loadNextWord: /api/next response:', {
                sentence: data.sentence,
                hint: data.hint,
                definition: data.definition,
                word: data.word,
                fullData: data
            });
            
            let chosen = '';
            if (data.sentence) {
                console.log('✓ Using sentence:', data.sentence);
                chosen = data.sentence;
            } else if (data.hint) {
                console.log('✓ Using hint:', data.hint);
                chosen = `Hint: ${data.hint}`;
            } else if (data.definition) {
                console.log('✓ Using definition:', data.definition);
                chosen = data.definition;
            } else {
                console.log('⚠️ No definition found, attempting /api/pronounce fallback');
                // Last resort fallback: try /api/pronounce for sentence/hint
                const pronounce = await this.fetchPronounce(true);
                chosen =
                    (pronounce && (pronounce.sentence || pronounce.hint))
                        ? (pronounce.sentence || `Hint: ${pronounce.hint}`)
                        : 'Listen carefully and spell the word you hear.';
                console.log('Using fallback:', chosen);
            }
            
            // Apply safety blanker to hide target word if it appears in the definition
            defBox.textContent = hideTargetWord(chosen, data.word);

            // Store the word data for pronunciation
            this.currentWordData = {
                word: data.word || '',
                definition: data.definition || ''
            };
            
            // Don't animate mascot on every question - keep it calm during gameplay
            // Mascot will only animate when answers are submitted

            // Announce the word like a real spelling bee, then pronounce it
            if (questionNumber === 1) {
                // First word already announced in intro
                await this.pronounceWord({ refresh: true });
            } else {
                // If this is the last word, announce it before giving the word
                if (this.totalWords && questionNumber === this.totalWords) {
                    const namePart = (this.studentName || '').trim();
                    const preface = namePart ? `${namePart}, this is your last word.` : `This is your last word.`;
                    await this.speakAnnouncement(preface);
                }
                // Subsequent words: consistent phrasing for clarity
                const phrase = `Your next word is: ${data.word}`;
                await this.speakAnnouncement(phrase);
                
                // Brief visual pause between phases, then auto‑pronounce
                {
                    const visualizer = document.getElementById('voiceVisualizer');
                    const status = document.getElementById('voiceStatus');
                    if (visualizer && status) {
                        visualizer.classList.add('pausing');
                        status.textContent = '⏸️ Pause...';
                    }
                    await new Promise(r => setTimeout(r, 500));
                    if (visualizer && status) {
                        visualizer.classList.remove('pausing');
                    }
                }
                
                await this.pronounceWord();
            }

            const spellingInput = document.getElementById('spellingInput');
            spellingInput.value = '';
            spellingInput.focus();

            this.hideFeedback();
            this.hideLetterHint();  // Hide letter hint for new word
            this.enableInput();
            this.delight?.clearFeedbackState();
            
            // ⏱️ Announce and start timer AFTER word announcement completes
            if (this.timerEnabled && this.quizStarted) {
                await this.announceAndStartTimer();
            }
        } catch (error) {
            console.error('Error loading next word:', error);
            BeeSmart.showError('Failed to load the next word. Please refresh the page.');
        }
    }

    async fetchPronounce(force = false) {
        if (!force && this.lastPronounceData) {
            return this.lastPronounceData;
        }

        try {
            const response = await fetch('/api/pronounce', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            if (!response.ok) {
                console.warn('Pronounce API failed:', response.status);
                return null;
            }
            const data = await response.json();
            if (data.error) {
                console.warn('Pronounce API error:', data.error);
                return null;
            }
            this.lastPronounceData = data;
            return data;
        } catch (error) {
            console.warn('Pronounce API exception:', error);
            return null;
        }
    }

    async getQuizState() {
        try {
            const response = await fetch('/api/next', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            if (!response.ok) {
                console.warn('Quiz state API failed:', response.status);
                return null;
            }
            const data = await response.json();
            if (data.error) {
                console.warn('Quiz state API error:', data.error);
                return null;
            }
            return data;
        } catch (error) {
            console.warn('Quiz state API exception:', error);
            return null;
        }
    }

    async getDefinition(options = {}) {
        try {
            if (options.refresh) {
                this.lastPronounceData = null;
                // Mark that hint was used for this word
                this.hintUsedThisWord = true;
                console.log('💡 Hint used - points will be reduced');
            }
            const data = await this.fetchPronounce(options.refresh);
            if (!data) {
                // Set a default message if API fails
                document.getElementById('definitionDisplay').textContent = 'Please spell the word you hear.';
                return;
            }

            const definitionElement = document.getElementById('definitionDisplay');
            
            // Format the definition in dictionary style
            const fullText = data.definition || 'Please spell the word you hear.';
            const pronunciation = data.phonetic || '';
            
            // Check if the definition contains "Fill in the blank:"
            if (fullText.includes('Fill in the blank:')) {
                const parts = fullText.split('Fill in the blank:');
                let definition = parts[0].trim();
                const sentence = parts[1] ? parts[1].trim() : '';
                
                // Remove emoji prefixes if present
                definition = definition.replace(/^[📖🔤📚]\s*/, '');
                
                // Extract word type if present (verb, noun, etc.)
                let wordType = '';
                const typeMatch = definition.match(/^\((verb|noun|adjective|adverb|pronoun|preposition|conjunction|interjection)\)/i);
                if (typeMatch) {
                    wordType = typeMatch[1];
                    definition = definition.replace(typeMatch[0], '').trim();
                }
                
                // Format with HTML for dictionary-style display
                definitionElement.innerHTML = `
                    ${pronunciation ? `<div class="pronunciation">🔊 [${pronunciation}]</div>` : ''}
                    ${wordType ? `<div class="word-type">${wordType}</div>` : ''}
                    <div class="word-definition"><span class="definition-number">1.</span>${definition}</div>
                    ${sentence ? `
                        <div class="sentence-example">
                            <span class="example-label">Example:</span>
                            <span class="example-text">${sentence}</span>
                        </div>
                    ` : ''}
                `;
            } else {
                // Clean format for simple definitions
                let cleanDef = fullText.replace(/^[📖🔤📚]\s*/, '');
                
                // Check for word type
                let wordType = '';
                const typeMatch = cleanDef.match(/^\((verb|noun|adjective|adverb|pronoun|preposition|conjunction|interjection)\)/i);
                if (typeMatch) {
                    wordType = typeMatch[1];
                    cleanDef = cleanDef.replace(typeMatch[0], '').trim();
                }
                
                definitionElement.innerHTML = `
                    ${pronunciation ? `<div class="pronunciation">🔊 [${pronunciation}]</div>` : ''}
                    ${wordType ? `<div class="word-type">${wordType}</div>` : ''}
                    <div class="word-definition"><span class="definition-number">1.</span>${cleanDef}</div>
                `;
            }
            
            // Show letter hint when user clicks "Honey Hint" button
            if (options.refresh) {
                this.showLetterHint();
                
                // Add bounce animation to definition
                definitionElement.classList.remove('hint-bounce');
                // Trigger reflow to restart animation
                void definitionElement.offsetWidth;
                definitionElement.classList.add('hint-bounce');
                
                // Remove animation class after it completes
                setTimeout(() => {
                    definitionElement.classList.remove('hint-bounce');
                }, 800);
            }
            
            if (!options.silent) {
                this.delight?.handleDefinition(data);
            } else {
                this.delight?.handleDefinition();
            }
        } catch (error) {
            console.error('Error getting definition:', error);
            // Set fallback message instead of breaking the quiz
            document.getElementById('definitionDisplay').textContent = 'Please spell the word you hear.';
        }
    }

    generateLetterHintPattern(word) {
        if (!word || word.length === 0) {
            return '';
        }
        
        const len = word.length;
        const letters = word.split('');
        let pattern = [];
        
        if (len === 1) {
            // Single letter - show the letter
            pattern = [letters[0]];
        } else if (len === 2) {
            // Two letters - show first and last
            pattern = [letters[0], letters[1]];
        } else if (len === 3) {
            // Three letters - show first and last, hide middle (e.g., d_g)
            pattern = [letters[0], '_', letters[2]];
        } else {
            // Four or more letters - show 1st, 3rd, and last
            for (let i = 0; i < len; i++) {
                if (i === 0 || i === 2 || i === len - 1) {
                    // Show 1st, 3rd, and last letter
                    pattern.push(letters[i]);
                } else {
                    // Hide other letters
                    pattern.push('_');
                }
            }
        }
        
        return pattern.join(' ');
    }

    showLetterHint() {
        const letterHintElement = document.getElementById('letterHint');
        const hintLettersElement = document.getElementById('hintLetters');
        
        if (!this.currentWordData || !this.currentWordData.word) {
            console.warn('No current word data available for letter hint');
            return;
        }
        
        const word = this.currentWordData.word;
        const hintPattern = this.generateLetterHintPattern(word);
        
        console.log(`💡 Showing letter hint for word (length ${word.length}): ${hintPattern}`);
        
        hintLettersElement.textContent = hintPattern;
        letterHintElement.classList.remove('hidden');
    }

    hideLetterHint() {
        const letterHintElement = document.getElementById('letterHint');
        letterHintElement.classList.add('hidden');
    }

    async pronounceWord({ refresh = false } = {}) {
        try {
            // Animate voice visualizer during actual speech
            const visualizer = document.getElementById('voiceVisualizer');
            const status = document.getElementById('voiceStatus');
            
            // Use stored word data instead of API call
            if (this.currentWordData && this.currentWordData.word) {
                const data = {
                    word: this.currentWordData.word,
                    definition: this.currentWordData.definition
                };
                
                // Start visualizer animation BEFORE speaking
                if (visualizer && status) {
                    console.log('🎤 Starting voice visualizer animation');
                    visualizer.classList.add('speaking');
                    status.textContent = '🗣️ Speaking...';
                }
                
                // Return a promise that resolves when speech ends to allow precise sequencing
                return await new Promise((resolve) => {
                    const onDone = () => {
                        console.log('🎤 Stopping voice visualizer animation');
                        if (visualizer && status) {
                            visualizer.classList.remove('speaking');
                            status.textContent = '🐝 Ready';
                        }
                        resolve();
                    };
                    // Prefer delight handler when available, otherwise speak directly
                    if (this.delight && typeof this.delight.handlePronounce === 'function') {
                        try {
                            this.delight.handlePronounce(data, onDone);
                        } catch (e) {
                            console.warn('handlePronounce failed, falling back to direct TTS:', e);
                            const phrase = `Spell the word ${data.word}. ${data.word}.`;
                            this.soundboard && this.soundboard.speakWord ? this.soundboard.speakWord(phrase, onDone) : onDone();
                        }
                    } else if (this.soundboard && typeof this.soundboard.speakWord === 'function') {
                        const phrase = `Spell the word ${data.word}. ${data.word}.`;
                        this.soundboard.speakWord(phrase, onDone);
                    } else {
                        onDone();
                    }
                });
            } else {
                console.warn('No word data available for pronunciation');
            }
        } catch (error) {
            console.error('Unable to pronounce word:', error);
            BeeSmart.showError('Could not pronounce the word right now. Please try again.');
            // Ensure visualizer stops on error
            const visualizer = document.getElementById('voiceVisualizer');
            const status = document.getElementById('voiceStatus');
            if (visualizer && status) {
                visualizer.classList.remove('speaking');
                status.textContent = '🐝 Ready';
            }
        }
    }

    async submitAnswer() {
        if (this.isAnswering) {
            return;
        }

        const spellingInput = document.getElementById('spellingInput');
        const userInput = spellingInput.value.trim();

        if (!userInput) {
            BeeSmart.showError('Please enter your spelling first!');
            spellingInput.focus();
            return;
        }

        this.isAnswering = true;
        this.disableInput();
        
        // ⏱️ Stop countdown timer when answer submitted
        this.stopCountdownTimer();

        try {
            const response = await fetch('/api/answer', {
                method: 'POST',
                credentials: 'same-origin',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_input: userInput,
                    method: 'keyboard',
                    elapsed_ms: 0
                })
            });

            if (!response.ok) {
                let errorMsg = 'Failed to submit answer';
                try {
                    const error = await response.json();
                    errorMsg = error.error || errorMsg;
                } catch (e) {
                    console.warn('Failed to parse error response as JSON:', e);
                }
                BeeSmart.showError(errorMsg);
                this.enableInput();
                return;
            }

            const result = await response.json();
            
            // 🍯 Update points from backend response
            if (result.points) {
                this.sessionPoints = result.points.session_total || this.sessionPoints;
                this.maxStreak = result.points.max_streak || this.maxStreak;
            }
            
            // Show feedback and wait for announcement to complete
            await this.showFeedback(result);
            
            this.updateScoreDisplay(result.progress);
            
            // 🏆 Check if quiz is complete and show badges/level-up
            if (result.quiz_complete) {
                console.log(`🏆 Quiz complete!`);
                
                // Small delay, then show all achievements
                setTimeout(async () => {
                    // Show badges first (if any)
                    if (result.badges && result.badges.length > 0) {
                        console.log(`🏆 ${result.badges.length} badge(s) earned!`);
                        await this.showAllBadges(result.badges);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    // 🎯 Show level up modal (if leveled up)
                    if (result.level_up && result.level_up.leveled_up) {
                        console.log(`🎯 Level up detected!`);
                        await this.showLevelUp(result.level_up);
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                    
                    // After all modals shown, load next word (which will show completion if quiz is done)
                    setTimeout(() => this.loadNextWord(), 800);
                }, 1500);
            } else {
                // Normal flow: Add a small delay after speech finishes, then load next word
                setTimeout(() => this.loadNextWord(), 800);
            }
            
        } catch (error) {
            BeeSmart.showError('Network error. Please try again.');
            this.enableInput();
        } finally {
            this.isAnswering = false;
        }
    }

    async showFeedback(result) {
        try { window.BeeVoiceViz?.react(result?.correct ? 'feedback-correct' : 'feedback-incorrect'); } catch (e) {}
        const feedbackArea = document.getElementById('feedbackArea');
        feedbackArea.style.display = 'block';
        
        // Use randomized feedback instead of server message
        const randomMessage = this.getRandomFeedback(result.correct);
        
    // Get audio announcement (may be a string or an object {phrase, name, pauseMs})
    const audioAnnouncement = this.getRandomAudioAnnouncement(result.correct);

        if (result.correct) {
            // � Use points from backend response
            const pointsData = result.points || {};
            const earnedPoints = pointsData.earned || 0;
            const breakdown = pointsData.breakdown || {};
            
            // Update streak
            this.currentStreak = result.progress?.streak || this.currentStreak;
            if (this.currentStreak > this.maxStreak) {
                this.maxStreak = this.currentStreak;
            }
            
            feedbackArea.className = 'feedback-area feedback-success';
            feedbackArea.innerHTML = `
                <div style="font-size: 1.15rem; font-weight: 700;">${randomMessage}</div>
                <div style="margin-top: 0.5rem;">Moving to the next word...</div>
            `;
            
            // Mascot celebrates!
            if (this.smartyBee) {
                this.smartyBee.onCorrectAnswer();
            }
            
            // Play honey collection sound on correct answer
            this.soundboard?.play('honey-collect');
            
            // Audio announcement - may include a separate name utterance after a short pause
            if (typeof audioAnnouncement === 'string') {
                await this.speakAnnouncement(audioAnnouncement);
            } else if (audioAnnouncement && audioAnnouncement.phrase) {
                await this.speakAnnouncement(audioAnnouncement.phrase);
                await new Promise(r => setTimeout(r, Math.max(200, Math.min(1000, audioAnnouncement.pauseMs || 350))));
                await this.speakAnnouncement(audioAnnouncement.name);
            }
            
            // 🍯 Display animated points popup if points earned
            if (earnedPoints > 0) {
                this.showPointsPopup(earnedPoints, breakdown);
            }
            
            // Visual explosion effect!
            this.createExplosion();
        } else {
            // Reset streak on incorrect answer
            this.currentStreak = 0;
            
            // Get the correct spelling from the current word data
            const correctWord = this.currentWordData?.word || result.word || '';
            
            feedbackArea.className = 'feedback-area feedback-error';
            feedbackArea.innerHTML = `
                <div style="font-size: 1.15rem; font-weight: 700;">${randomMessage}</div>
                <div style="margin-top: 0.5rem;">The correct spelling is: <strong>${correctWord}</strong></div>
                <div style="margin-top: 0.3rem;">Moving to the next word...</div>
            `;
            
            // Mascot encourages!
            if (this.smartyBee) {
                this.smartyBee.onIncorrectAnswer();
            }
            
            // Spell out the word letter by letter
            const spelledOut = correctWord.split('').join(', ').toUpperCase();
            // Speak feedback; if announcement was split, preserve the pause structure
            if (typeof audioAnnouncement === 'string') {
                const announcement = `${audioAnnouncement}. The correct spelling is: ${spelledOut}`;
                await this.speakAnnouncement(announcement);
            } else if (audioAnnouncement && audioAnnouncement.phrase) {
                await this.speakAnnouncement(audioAnnouncement.phrase);
                await new Promise(r => setTimeout(r, Math.max(200, Math.min(1000, audioAnnouncement.pauseMs || 350))));
                await this.speakAnnouncement(audioAnnouncement.name);
                await this.speakAnnouncement(`The correct spelling is: ${spelledOut}`);
            }
        }

        this.delight?.handleFeedback(result);
    }

    hideFeedback() {
        const feedbackArea = document.getElementById('feedbackArea');
        feedbackArea.style.display = 'none';
    }

    updateScoreDisplay(progress = {}) {
        const total = progress.total ?? this.totalWords ?? 0;
        if (Number.isFinite(total) && total > 0) {
            this.totalWords = total;
        }

        const correct = Number(progress.correct) || 0;
        const incorrect = Number(progress.incorrect) || 0;
        const streak = Number(progress.streak ?? this.currentStreak) || 0;
        
        // Ensure we never display NaN
        document.getElementById('correctCount').textContent = correct;
        document.getElementById('incorrectCount').textContent = incorrect;
        document.getElementById('streakCount').textContent = streak;
        
        // 🏆 Update session points display (if element exists)
        const sessionPointsElement = document.getElementById('sessionPoints');
        if (sessionPointsElement) {
            const points = Number(this.sessionPoints) || 0;
            sessionPointsElement.textContent = points.toLocaleString();
        }

        // Update honey jar fill level based on progress
        const honeyLevel = document.getElementById('honeyLevel');
        if (honeyLevel && this.totalWords > 0) {
            const percentage = Math.min(100, Math.max(0, (correct / this.totalWords) * 100));
            if (Number.isFinite(percentage)) {
                honeyLevel.style.height = percentage + '%';
                console.log(`🍯 Honey jar filled to ${percentage.toFixed(1)}% (${correct}/${this.totalWords})`);
            }
        }

        this.delight?.updateProgress({ ...progress, total: this.totalWords });
    }

    resetHoneyJar() {
        // Reset honey jar to 0% (empty) at start of quiz
        const honeyLevel = document.getElementById('honeyLevel');
        if (honeyLevel) {
            honeyLevel.style.height = '0%';
            console.log('🍯 Honey jar reset to 0% for new quiz');
        }
    }

    disableInput() {
        document.getElementById('spellingInput').disabled = true;
        document.getElementById('submitButton').disabled = true;
    }

    enableInput() {
        document.getElementById('spellingInput').disabled = false;
        document.getElementById('submitButton').disabled = false;
    }

    async skipWord() {
        // ⏱️ Stop countdown timer when skipping
        this.stopCountdownTimer();
        
        try {
            await fetch('/api/answer', {
                method: 'POST',
                credentials: 'same-origin',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    user_input: '',
                    method: 'skip',
                    elapsed_ms: 0
                })
            });
            this.delight?.handleSkip();
            this.loadNextWord();
        } catch (error) {
            console.error('Error skipping word:', error);
        }
    }

    async announceQuizEnding() {
        // Announce that the quiz has ended and report card is coming
        const announcement = "That's the end of the quiz. Please wait for your quiz results.";
        
        try {
            await this.speakAnnouncement(announcement);
            // Add a brief pause after the announcement
            await new Promise(resolve => setTimeout(resolve, 500));
        } catch (error) {
            console.error('Error announcing quiz ending:', error);
        }
    }

    async showQuizComplete(summary) {
        document.getElementById('quizCard').style.display = 'none';
        const completeDiv = document.getElementById('quizComplete');
        completeDiv.style.display = 'block';

        // Ensure no NaN values in summary
        const total = Number(summary.total) || 1; // Avoid division by zero
        const correct = Number(summary.correct) || 0;
        const incorrect = Number(summary.incorrect) || 0;
        
        const percentage = Math.round((correct / total) * 100);
        const safePercentage = Number.isFinite(percentage) ? percentage : 0;
        
        // Calculate letter grade
        let letterGrade = '';
        let gradeColor = '';
        let gradeEmoji = '';
        let gradeMessage = '';
        
        if (safePercentage >= 90) {
            letterGrade = 'A';
            gradeColor = '#2ecc71'; // Green
            gradeEmoji = '🌟';
            gradeMessage = 'Outstanding! You\'re a spelling superstar!';
        } else if (safePercentage >= 80) {
            letterGrade = 'B';
            gradeColor = '#3498db'; // Blue
            gradeEmoji = '🎯';
            gradeMessage = 'Great job! You\'re doing really well!';
        } else if (safePercentage >= 70) {
            letterGrade = 'C';
            gradeColor = '#f39c12'; // Orange
            gradeEmoji = '👍';
            gradeMessage = 'Good work! Keep practicing!';
        } else if (safePercentage >= 60) {
            letterGrade = 'D';
            gradeColor = '#e67e22'; // Dark Orange
            gradeEmoji = '💪';
            gradeMessage = 'Nice try! Practice makes perfect!';
        } else {
            letterGrade = 'F';
            gradeColor = '#e74c3c'; // Red
            gradeEmoji = '🐝';
            gradeMessage = 'Keep buzzing! Every bee starts somewhere!';
        }
        
        // Get badges from session state
        const state = await this.getQuizState();
        const badgesEarned = state?.badges_earned || [];
        
        // Get user's current level
        let levelHTML = '';
        try {
            const levelResponse = await fetch('/api/user/level', {
                method: 'GET',
                credentials: 'same-origin'
            });
            if (levelResponse.ok) {
                const levelData = await levelResponse.json();
                if (levelData.success && levelData.level) {
                    const level = levelData.level;
                    const progressPercent = level.progress_percent || 0;
                    
                    levelHTML = `
                        <div style="
                            background: linear-gradient(135deg, #9b59b6 15%, #8e44ad 85%);
                            border-radius: 20px;
                            padding: 1.5rem;
                            margin-bottom: 1.5rem;
                            box-shadow: 0 10px 30px rgba(142, 68, 173, 0.4);
                            animation: slideInDown 0.6s ease 0.3s backwards;
                            text-align: center;
                        ">
                            <div style="font-size: 4rem; margin-bottom: 0.5rem; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">
                                ${level.icon}
                            </div>
                            <div style="font-size: 1.8rem; font-weight: 800; color: white; margin-bottom: 0.3rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                                ${level.tier}
                            </div>
                            <div style="font-size: 1rem; color: rgba(255,255,255,0.9); margin-bottom: 1rem;">
                                Level ${level.level}
                            </div>
                            ${!level.is_max_level ? `
                                <div style="
                                    background: rgba(255, 255, 255, 0.3);
                                    border-radius: 10px;
                                    height: 12px;
                                    overflow: hidden;
                                    margin-bottom: 0.5rem;
                                ">
                                    <div style="
                                        width: ${progressPercent}%;
                                        height: 100%;
                                        background: linear-gradient(90deg, #FFD700, #FFA500);
                                        border-radius: 10px;
                                        transition: width 1s ease;
                                        box-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
                                    "></div>
                                </div>
                                <div style="font-size: 0.9rem; color: rgba(255,255,255,0.95);">
                                    ${level.points_to_next.toLocaleString()} points to next level
                                </div>
                            ` : `
                                <div style="font-size: 1rem; color: rgba(255,255,255,0.95); margin-top: 0.5rem;">
                                    👑 Maximum Level Achieved! 👑
                                </div>
                            `}
                        </div>
                    `;
                }
            }
        } catch (error) {
            console.warn('Failed to load level data:', error);
        }
        
        // Build badges HTML
        let badgesHTML = '';
        if (badgesEarned.length > 0) {
            badgesHTML = `
                <div style="
                    background: linear-gradient(135deg, #FFD700 15%, #FFA500 85%);
                    border-radius: 20px;
                    padding: 1.5rem;
                    margin: 1.5rem 0;
                    box-shadow: 0 10px 30px rgba(255, 152, 0, 0.4);
                    animation: slideInUp 0.6s ease 0.6s backwards;
                ">
                    <div style="font-size: 1.5rem; font-weight: 800; color: white; margin-bottom: 1rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                        🏆 Badges Earned This Session!
                    </div>
                    <div style="display: flex; flex-wrap: wrap; gap: 1rem; justify-content: center;">
                        ${badgesEarned.map(badge => `
                            <div style="
                                background: rgba(255, 255, 255, 0.95);
                                border-radius: 15px;
                                padding: 1rem;
                                min-width: 140px;
                                text-align: center;
                                box-shadow: 0 6px 15px rgba(0,0,0,0.2);
                                border: 2px solid rgba(255, 215, 0, 0.6);
                            ">
                                <div style="font-size: 3rem; margin-bottom: 0.5rem;">${badge.icon}</div>
                                <div style="font-size: 0.95rem; font-weight: 700; color: #5A2C15; margin-bottom: 0.3rem;">
                                    ${badge.name}
                                </div>
                                <div style="font-size: 1.2rem; font-weight: 800; color: #FFB300;">
                                    +${badge.points} pts
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }
        
        document.getElementById('completionStats').innerHTML = `
            <div class="report-card">
                <div class="report-header">
                    <h2>📚 ${(() => {
                        const n = (this.studentName || '').trim();
                        if (!n) return 'Your Report Card!';
                        const lower = n.toLowerCase();
                        const endsWithS = lower.endsWith('s');
                        const possessive = endsWithS ? `${n}'` : `${n}'s`;
                        return `${possessive} Report Card!`;
                    })()}</h2>
                    <p class="sub">Great job practicing your spelling!</p>
                </div>

                <div class="grade-block">
                    <div class="grade-bubble" style="background: linear-gradient(135deg, ${gradeColor} 0%, ${gradeColor}dd 100%);">
                        ${letterGrade}
                    </div>
                    <div class="grade-emoji">${gradeEmoji}</div>
                    <div class="grade-message">${gradeMessage}</div>
                </div>

                <div class="tall-stats">
                    <div class="tall-stat-card">
                        <div class="stat-icon">📚</div>
                        <div class="stat-number">${total}</div>
                        <div class="stat-label">Total Words</div>
                    </div>
                    <div class="tall-stat-card success">
                        <div class="stat-icon">✅</div>
                        <div class="stat-number">${correct}</div>
                        <div class="stat-label">Correct</div>
                    </div>
                </div>

                <div class="grid-stats">
                    <div class="fancy-stat-card danger">
                        <div class="stat-icon">❌</div>
                        <h3>${incorrect}</h3>
                        <p>Incorrect</p>
                    </div>
                    <div class="fancy-stat-card warning">
                        <div class="stat-icon">🎯</div>
                        <h3>${safePercentage}%</h3>
                        <p>Accuracy</p>
                    </div>
                    <div class="fancy-stat-card gold">
                        <div class="stat-icon">🏆</div>
                        <h3>${(Number(this.sessionPoints) || 0).toLocaleString()}</h3>
                        <p>Total Points</p>
                    </div>
                    <div class="fancy-stat-card purple">
                        <div class="stat-icon">🔥</div>
                        <h3>${Number(this.maxStreak) || 0}</h3>
                        <p>Best Streak</p>
                    </div>
                </div>

                <!-- Honey Pot Progress -->
                <div class="honey-pot-container">
                    <div class="honey-title">🍯 Honey Collected This Session</div>
                    <div class="honey-pot">
                        <!-- Honey level fill -->
                        <div class="honey-fill" style="height: ${safePercentage}%;"></div>
                        
                        <!-- Honey pot label -->
                        <div class="honey-label">${safePercentage}%</div>
                        
                        <!-- Pot rim -->
                        <div class="pot-rim"></div>
                    </div>
                    <div class="honey-sub">Keep spelling to fill your pot! 🐝</div>
                </div>

                <!-- Achievements moved below for breathing room -->
                ${badgesHTML}
                ${levelHTML}
            </div>
            
            <style>
                .report-card {
                    max-width: 560px;
                    margin: 0 auto;
                    padding: 1.25rem 1rem 2rem;
                    background: linear-gradient(180deg, #FFF9E9, #FFF5DD);
                    border-radius: 24px;
                    border: 4px solid rgba(255, 182, 193, 0.45);
                    box-shadow: 0 20px 60px rgba(0,0,0,0.12);
                }
                .report-header { text-align: center; margin-bottom: 0.75rem; }
                .report-header h2 { margin: 0; font-size: 1.4rem; color: #5A2C15; }
                .report-header .sub { margin: 0.35rem 0 0; color: #7A4A2A; font-weight: 600; font-size: 0.95rem; opacity: 0.9; }

                .grade-block { text-align: center; margin: 0.75rem 0 1.25rem; }
                .grade-bubble {
                    display: inline-flex; align-items: center; justify-content: center;
                    color: #fff; font-size: 4.25rem; font-weight: 900; width: 132px; height: 132px;
                    border-radius: 50%; border: 6px solid rgba(255,255,255,0.9);
                    box-shadow: 0 15px 40px rgba(0,0,0,0.25);
                    animation: gradePopIn 0.6s cubic-bezier(0.68,-0.55,0.265,1.55);
                    margin: 0 auto 0.5rem;
                }
                .grade-emoji { font-size: 2.1rem; margin-bottom: 0.25rem; }
                .grade-message { font-size: 1.05rem; color: #5A2C15; font-weight: 600; line-height: 1.45; }

                .tall-stats {
                    display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin: 0.5rem 0 0.5rem;
                }
                .tall-stat-card {
                    background: linear-gradient(135deg, #FFF5D7 0%, #FFE1F2 100%);
                    border-radius: 20px; padding: 1rem 0.5rem 1.2rem; text-align: center;
                    border: 3px solid rgba(255, 182, 193, 0.35);
                    box-shadow: 0 10px 28px rgba(255,193,7,0.2);
                    min-height: 150px; display: flex; flex-direction: column; align-items: center; justify-content: center;
                }
                .tall-stat-card.success { background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%); color: #fff; border-color: rgba(255,255,255,0.35); }
                .tall-stat-card .stat-icon { font-size: 2rem; margin-bottom: 0.25rem; }
                .tall-stat-card .stat-number { font-size: 2.1rem; font-weight: 900; margin: 0.1rem 0; }
                .tall-stat-card .stat-label { font-weight: 700; opacity: 0.95; }

                .grid-stats {
                    display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin: 0.5rem 0 0.25rem;
                }
                .fancy-stat-card { background: linear-gradient(135deg, #FFF5D7 0%, #FFE1F2 100%); border-radius: 18px; padding: 1.1rem 0.8rem; border: 3px solid rgba(255,182,193,0.35); box-shadow: 0 10px 28px rgba(255,193,7,0.2); text-align: center; }
                .fancy-stat-card .stat-icon { font-size: 2.1rem; margin-bottom: 0.35rem; }
                .fancy-stat-card h3 { font-size: 2.1rem; font-weight: 900; margin: 0.2rem 0; }
                .fancy-stat-card p { font-size: 0.95rem; font-weight: 700; margin: 0; opacity: 0.95; }
                .fancy-stat-card.danger { background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%); color: #fff; border-color: rgba(255,255,255,0.35); }
                .fancy-stat-card.warning { background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%); color: #fff; border-color: rgba(255,255,255,0.35); }
                .fancy-stat-card.gold { background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: #fff; border-color: rgba(255,255,255,0.35); }
                .fancy-stat-card.purple { background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: #fff; border-color: rgba(255,255,255,0.35); }

                .honey-pot-container { text-align: center; margin-top: 1.1rem; }
                .honey-title { font-size: 1.05rem; font-weight: 800; color: #5A2C15; margin-bottom: 0.6rem; }
                .honey-pot { position: relative; width: 200px; height: 180px; margin: 0.25rem auto 0; background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); border-radius: 20px 20px 40px 40px; border: 4px solid #8B4513; box-shadow: 0 10px 30px rgba(255,165,0,0.35), inset 0 -20px 40px rgba(139,69,19,0.18); overflow: hidden; }
                .honey-fill { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(180deg, rgba(255, 223, 0, 0.9) 0%, rgba(255, 193, 7, 1) 100%); border-radius: 0 0 36px 36px; animation: honeyFill 1.5s ease-out 0.6s backwards; box-shadow: inset 0 10px 20px rgba(255,255,255,0.3); }
                .honey-label { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2.3rem; font-weight: 900; color: #8B4513; text-shadow: 2px 2px 4px rgba(255,255,255,0.5); z-index: 10; }
                .pot-rim { position: absolute; top: -8px; left: -4px; right: -4px; height: 20px; background: linear-gradient(135deg, #A0522D 0%, #8B4513 100%); border-radius: 20px 20px 0 0; border: 2px solid #654321; }
                .honey-sub { margin-top: 0.75rem; font-size: 0.95rem; color: #5A2C15; font-weight: 600; }

                @media (max-width: 460px) {
                    .tall-stats, .grid-stats { grid-template-columns: 1fr; }
                    .report-card { padding: 1rem 0.75rem 1.5rem; }
                }
            </style>
            
            <style>
                @keyframes honeyFill {
                    from { height: 0%; }
                    to { height: ${safePercentage}%; }
                }
            </style>
            
            <style>
                @keyframes gradePopIn {
                    from {
                        transform: scale(0) rotate(-180deg);
                        opacity: 0;
                    }
                    to {
                        transform: scale(1) rotate(0deg);
                        opacity: 1;
                    }
                }

                @keyframes slideInLeft {
                    from {
                        transform: translateX(-50px);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                @keyframes slideInRight {
                    from {
                        transform: translateX(50px);
                        opacity: 0;
                    }
                    to {
                        transform: translateX(0);
                        opacity: 1;
                    }
                }
                
                /* legacy fancy-stat-card base kept above, hover reduced to keep spacing calm */
            </style>
        `;

        this.delight?.setTotalQuestions(summary.total);
        this.delight?.updateProgress({ correct: summary.correct, total: summary.total });
        this.delight?.setMascotState('happy', 2200);
        
        // Mascot celebrates quiz completion!
        if (this.smartyBee) {
            this.smartyBee.onQuizComplete();
        }

        BeeSmart.showSuccess(`Quiz complete! You got ${summary.correct} out of ${summary.total} words correct (${percentage}%). Grade: ${letterGrade}`);
    }

    async restartQuiz() {
        try {
            await fetch('/api/reset', { 
                method: 'POST',
                credentials: 'same-origin'
            });
            window.location.reload();
        } catch (error) {
            BeeSmart.showError('Failed to restart quiz. Please refresh the page.');
        }
    }
}

// Kid-friendly confirmation for back to menu
function confirmBackToMenu(event) {
    event.preventDefault();
    
    // 🛑 FULL CLEANUP: Stop all quiz activities immediately
    console.log('🛑 Starting full quiz cleanup for back navigation...');
    
    // 1. Stop any ongoing announcer speech immediately
    if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
        console.log('🔇 Stopped announcer speech');
    }
    
    // 2. Clear any active countdown timers
    if (window.spellingQuiz && window.spellingQuiz.countdownTimer) {
        clearInterval(window.spellingQuiz.countdownTimer);
        window.spellingQuiz.countdownTimer = null;
        console.log('⏱️ Cleared countdown timer');
    }
    
    // 3. Stop any audio context or sound effects
    if (window.AudioContext || window.webkitAudioContext) {
        try {
            const contexts = window.audioContexts || [];
            contexts.forEach(ctx => {
                if (ctx.state !== 'closed') {
                    ctx.close();
                }
            });
            console.log('🔊 Closed audio contexts');
        } catch (e) {
            console.log('Audio context cleanup attempted:', e);
        }
    }
    
    // 4. Clear any pending timeouts/intervals
    if (window.spellingQuiz && window.spellingQuiz.currentWordTimeout) {
        clearTimeout(window.spellingQuiz.currentWordTimeout);
        console.log('⏰ Cleared pending timeouts');
    }
    
    console.log('✅ Quiz cleanup complete');
    
    // Create kid-friendly modal
    const modal = document.createElement('div');
    modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        animation: fadeIn 0.3s ease;
    `;
    
    modal.innerHTML = `
        <div style="
            background: linear-gradient(135deg, #FFF5D7 0%, #FFE1F2 100%);
            padding: 2rem;
            border-radius: 24px;
            max-width: 420px;
            margin: 1rem;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4);
            border: 4px solid rgba(255, 182, 193, 0.6);
            animation: modalSlideIn 0.3s ease;
        ">
            <div style="font-size: 3rem; margin-bottom: 1rem;">🐝</div>
            <h2 style="color: #D2691E; margin-bottom: 1rem; font-size: 1.5rem;">
                Are you sure you want to go back?
            </h2>
            <p style="color: #5A2C15; line-height: 1.6; margin-bottom: 1.5rem; font-size: 1.1rem;">
                🍯 Going back to the menu will end your current quiz and reset your progress!
                <br><br>
                <strong>Your scores will be lost.</strong>
            </p>
            <div style="display: flex; gap: 1rem; justify-content: center;">
                <button id="confirmBack" style="
                    background: linear-gradient(135deg, #FF6B6B 0%, #FF8E53 100%);
                    color: white;
                    border: none;
                    padding: 0.9rem 1.8rem;
                    border-radius: 16px;
                    font-weight: 700;
                    font-size: 1rem;
                    cursor: pointer;
                    box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
                    transition: all 0.2s;
                    border: 3px solid rgba(255, 255, 255, 0.4);
                ">
                    Yes, Go Back
                </button>
                <button id="cancelBack" style="
                    background: linear-gradient(135deg, #A8E6CF 0%, #6BCF7F 100%);
                    color: #1a5c3a;
                    border: none;
                    padding: 0.9rem 1.8rem;
                    border-radius: 16px;
                    font-weight: 700;
                    font-size: 1rem;
                    cursor: pointer;
                    box-shadow: 0 8px 20px rgba(168, 230, 207, 0.4);
                    transition: all 0.2s;
                    border: 3px solid rgba(255, 255, 255, 0.4);
                ">
                    Stay Here
                </button>
            </div>
        </div>
    `;
    
    document.body.appendChild(modal);
    
    const confirmBtn = document.getElementById('confirmBack');
    const cancelBtn = document.getElementById('cancelBack');
    
    // Button hover effects
    confirmBtn.addEventListener('mouseenter', () => {
        confirmBtn.style.transform = 'scale(1.05) translateY(-2px)';
        confirmBtn.style.boxShadow = '0 12px 28px rgba(255, 107, 107, 0.6)';
    });
    confirmBtn.addEventListener('mouseleave', () => {
        confirmBtn.style.transform = 'scale(1)';
        confirmBtn.style.boxShadow = '0 8px 20px rgba(255, 107, 107, 0.4)';
    });
    
    cancelBtn.addEventListener('mouseenter', () => {
        cancelBtn.style.transform = 'scale(1.05) translateY(-2px)';
        cancelBtn.style.boxShadow = '0 12px 28px rgba(168, 230, 207, 0.6)';
    });
    cancelBtn.addEventListener('mouseleave', () => {
        cancelBtn.style.transform = 'scale(1)';
        cancelBtn.style.boxShadow = '0 8px 20px rgba(168, 230, 207, 0.4)';
    });
    
    // Click handlers
    confirmBtn.addEventListener('click', () => {
        modal.remove();
        
        // Final cleanup before navigation
        if ('speechSynthesis' in window) {
            speechSynthesis.cancel();
        }
        
        // Navigate to home
        window.location.href = '/';
    });
    
    cancelBtn.addEventListener('click', () => {
        modal.remove();
        // Resume quiz if user cancels
        console.log('↩️ User cancelled back navigation, resuming quiz');
    });
    
    // Close on background click
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });
}

// 🍎 iOS Audio Unlock - MUST run before any speech synthesis
function unlockiOSAudio() {
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    if (!isIOS) return;
    
    console.log('🍎 iOS detected - setting up audio unlock');
    
    // Silent utterance to wake up speech synthesis on first user interaction
    const unlock = () => {
        console.log('🔓 Unlocking iOS audio...');
        
        // Method 1: Silent speech utterance
        const utterance = new SpeechSynthesisUtterance(' ');
        utterance.volume = 0.01; // Almost silent
        speechSynthesis.speak(utterance);
        setTimeout(() => speechSynthesis.cancel(), 100);
        
        // Method 2: Resume AudioContext if exists
        if (window.AudioContext || window.webkitAudioContext) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('✅ AudioContext resumed');
                });
            }
        }
        
        console.log('✅ iOS audio unlocked');
        
        // Remove listeners after first unlock
        document.removeEventListener('touchstart', unlock);
        document.removeEventListener('click', unlock);
    };
    
    // Listen for first user interaction
    document.addEventListener('touchstart', unlock, { once: true });
    document.addEventListener('click', unlock, { once: true });
}

// 🛡️ Safe JSON parsing helper
function safeParseJSON(txt, label = 'payload') {
    try { 
        return JSON.parse(txt); 
    } catch (e) {
        console.error(`JSON parse failed for ${label}:`, txt.slice(0, 300), e);
        throw new Error(`Invalid JSON in ${label}: ${e.message}`);
    }
}

// 🛡️ Global error handler for syntax errors
window.addEventListener('error', (event) => {
    if (event.error && event.error.message && event.error.message.includes('Unexpected token')) {
        console.error('🚨 JavaScript syntax error detected:', {
            message: event.error.message,
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            stack: event.error.stack
        });
        // Show user-friendly error message
        if (typeof BeeSmart !== 'undefined' && BeeSmart.showError) {
            BeeSmart.showError('Page loading error detected. Refreshing...');
        } else {
            alert('Page loading error. Refreshing...');
        }
        setTimeout(() => window.location.reload(), 2000);
        return true; // Prevent default error handling
    }
});

// Call immediately on page load
unlockiOSAudio();

document.addEventListener('DOMContentLoaded', async () => {
    try {
    const delight = new BeeDelightManager();
    
    // Bee swarm and hive removed - too distracting during quiz
    // Only keep the 3D mascot bee for companionship
    
    // Initialize 3D Mascot with user's selected avatar
    let smartyBee = null;
    try {
        // Wait for avatar loader to fetch user's avatar
        await window.userAvatarLoader.init();
        
        // Get avatar options from loader
        const avatarOptions = window.userAvatarLoader.getAvatarOptions({
            width: 180,
            height: 180,
            autoRotate: true,
            enableInteraction: true
        });
        
    // Render into mascot container (replaces old smartyBee3D)
    smartyBee = new SmartyBee3D('mascotBee3D', avatarOptions);
        
        const avatarId = window.userAvatarLoader.getAvatarId();
        console.log(`✨ 3D mascot initialized with avatar: ${avatarId}`);
    } catch (error) {
        console.warn('3D mascot failed to load:', error);
    }

    fetch('/api/wordbank', {
        credentials: 'same-origin',  // CRITICAL: Ensure session cookie is sent
        cache: 'no-store',
        headers: {
            'Cache-Control': 'no-cache'
        }
    })
        .then(response => response.json())
        .then(data => {
            if (!data.words || data.words.length === 0) {
                BeeSmart.showError('No words loaded for the quiz!');
                setTimeout(() => window.location.href = '/', 2800);
                return;
            }

            window.quizManager = new QuizManager({ delight, smartyBee });
        })
        .catch(error => {
            console.error('Failed to check word bank:', error);
            BeeSmart.showError('Failed to check word bank. Redirecting to main menu...');
            setTimeout(() => window.location.href = '/', 2800);
        });
    } catch (error) {
        console.error('🚨 Critical initialization error:', error);
        if (typeof BeeSmart !== 'undefined' && BeeSmart.showError) {
            BeeSmart.showError('Quiz initialization failed. Redirecting to main menu...');
        } else {
            alert('Quiz initialization failed. Redirecting to main menu...');
        }
        setTimeout(() => window.location.href = '/', 2000);
    }
});

// 💾 Save partial progress before user leaves
// This ensures points, achievements, and progress are saved even if quiz is incomplete
window.addEventListener('beforeunload', async (event) => {
    // 🛑 CRITICAL: Stop all quiz activities before leaving
    console.log('🛑 Page unloading - stopping all quiz activities...');
    
    // Stop speech synthesis immediately (most important)
    if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
        console.log('🔇 Speech synthesis stopped on unload');
    }
    
    // Clear all timers
    if (window.spellingQuiz) {
        if (window.spellingQuiz.countdownTimer) {
            clearInterval(window.spellingQuiz.countdownTimer);
        }
        if (window.spellingQuiz.currentWordTimeout) {
            clearTimeout(window.spellingQuiz.currentWordTimeout);
        }
    }
    
    // Save progress
    try {
        // Use sendBeacon for reliable delivery even during page unload
        const response = await fetch('/api/save-partial-progress', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            keepalive: true  // Ensures request completes even if page is closing
        });
        
        if (response.ok) {
            console.log('✅ Partial quiz progress saved');
        }
    } catch (error) {
        // Use sendBeacon as fallback (more reliable during unload)
        const blob = new Blob([JSON.stringify({})], { type: 'application/json' });
        navigator.sendBeacon('/api/save-partial-progress', blob);
        console.log('💾 Progress save sent via beacon');
    }
});

// Also save when navigating away programmatically
window.addEventListener('pagehide', () => {
    // 🛑 Final cleanup on page hide
    console.log('🛑 Page hidden - final cleanup...');
    
    // Stop all speech immediately
    if ('speechSynthesis' in window) {
        speechSynthesis.cancel();
    }
    
    // Clear all timers
    if (window.spellingQuiz) {
        if (window.spellingQuiz.countdownTimer) {
            clearInterval(window.spellingQuiz.countdownTimer);
        }
        if (window.spellingQuiz.currentWordTimeout) {
            clearTimeout(window.spellingQuiz.currentWordTimeout);
        }
    }
    
    // Save progress via beacon
    const blob = new Blob([JSON.stringify({})], { type: 'application/json' });
    navigator.sendBeacon('/api/save-partial-progress', blob);
    console.log('✅ Final cleanup complete');
});
</script>
{% endblock %}